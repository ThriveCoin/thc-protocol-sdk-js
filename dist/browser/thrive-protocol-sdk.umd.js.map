{"version":3,"file":"thrive-protocol-sdk.umd.js","sources":["../../node_modules/ethers/lib.esm/utils/properties.js","../../node_modules/ethers/lib.esm/utils/errors.js","../../node_modules/ethers/lib.esm/utils/data.js","../../node_modules/ethers/lib.esm/utils/maths.js","../../node_modules/ethers/lib.esm/utils/events.js","../../node_modules/ethers/lib.esm/utils/utf8.js","../../node_modules/ethers/lib.esm/utils/fixednumber.js","../../node_modules/ethers/lib.esm/utils/units.js","../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js","../../node_modules/@noble/hashes/esm/_assert.js","../../node_modules/@noble/hashes/esm/_u64.js","../../node_modules/@noble/hashes/esm/utils.js","../../node_modules/@noble/hashes/esm/sha3.js","../../node_modules/ethers/lib.esm/crypto/keccak.js","../../node_modules/ethers/lib.esm/constants/addresses.js","../../node_modules/ethers/lib.esm/address/address.js","../../node_modules/ethers/lib.esm/address/checks.js","../../node_modules/ethers/lib.esm/abi/typed.js","../../node_modules/ethers/lib.esm/abi/coders/address.js","../../node_modules/ethers/lib.esm/abi/coders/anonymous.js","../../node_modules/ethers/lib.esm/abi/coders/array.js","../../node_modules/ethers/lib.esm/abi/coders/boolean.js","../../node_modules/ethers/lib.esm/abi/coders/bytes.js","../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js","../../node_modules/ethers/lib.esm/abi/coders/null.js","../../node_modules/ethers/lib.esm/abi/coders/number.js","../../node_modules/ethers/lib.esm/abi/coders/string.js","../../node_modules/ethers/lib.esm/abi/coders/tuple.js","../../node_modules/ethers/lib.esm/hash/id.js","../../node_modules/ethers/lib.esm/transaction/accesslist.js","../../node_modules/ethers/lib.esm/hash/solidity.js","../../node_modules/ethers/lib.esm/abi/fragments.js","../../node_modules/ethers/lib.esm/abi/abi-coder.js","../../node_modules/ethers/lib.esm/abi/interface.js","../../node_modules/ethers/lib.esm/providers/provider.js","../../node_modules/ethers/lib.esm/contract/wrappers.js","../../node_modules/ethers/lib.esm/contract/contract.js"],"sourcesContent":["/**\n *  Property helper functions.\n *\n *  @_subsection api/utils:Properties  [about-properties]\n */\nfunction checkType(value, type, name) {\n    const types = type.split(\"|\").map(t => t.trim());\n    for (let i = 0; i < types.length; i++) {\n        switch (type) {\n            case \"any\":\n                return;\n            case \"bigint\":\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n                if (typeof (value) === type) {\n                    return;\n                }\n        }\n    }\n    const error = new Error(`invalid value for type ${type}`);\n    error.code = \"INVALID_ARGUMENT\";\n    error.argument = `value.${name}`;\n    error.value = value;\n    throw error;\n}\n/**\n *  Resolves to a new object that is a copy of %%value%%, but with all\n *  values resolved.\n */\nexport async function resolveProperties(value) {\n    const keys = Object.keys(value);\n    const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));\n    return results.reduce((accum, v, index) => {\n        accum[keys[index]] = v;\n        return accum;\n    }, {});\n}\n/**\n *  Assigns the %%values%% to %%target%% as read-only values.\n *\n *  It %%types%% is specified, the values are checked.\n */\nexport function defineProperties(target, values, types) {\n    for (let key in values) {\n        let value = values[key];\n        const type = (types ? types[key] : null);\n        if (type) {\n            checkType(value, type, key);\n        }\n        Object.defineProperty(target, key, { enumerable: true, value, writable: false });\n    }\n}\n//# sourceMappingURL=properties.js.map","/**\n *  All errors in ethers include properties to ensure they are both\n *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).\n *\n *  The [[isError]] function can be used to check the error ``code`` and\n *  provide a type guard for the properties present on that error interface.\n *\n *  @_section: api/utils/errors:Errors  [about-errors]\n */\nimport { version } from \"../_version.js\";\nimport { defineProperties } from \"./properties.js\";\nfunction stringify(value) {\n    if (value == null) {\n        return \"null\";\n    }\n    if (Array.isArray(value)) {\n        return \"[ \" + (value.map(stringify)).join(\", \") + \" ]\";\n    }\n    if (value instanceof Uint8Array) {\n        const HEX = \"0123456789abcdef\";\n        let result = \"0x\";\n        for (let i = 0; i < value.length; i++) {\n            result += HEX[value[i] >> 4];\n            result += HEX[value[i] & 0xf];\n        }\n        return result;\n    }\n    if (typeof (value) === \"object\" && typeof (value.toJSON) === \"function\") {\n        return stringify(value.toJSON());\n    }\n    switch (typeof (value)) {\n        case \"boolean\":\n        case \"symbol\":\n            return value.toString();\n        case \"bigint\":\n            return BigInt(value).toString();\n        case \"number\":\n            return (value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{ \" + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(\", \") + \" }\";\n        }\n    }\n    return `[ COULD NOT SERIALIZE ]`;\n}\n/**\n *  Returns true if the %%error%% matches an error thrown by ethers\n *  that matches the error %%code%%.\n *\n *  In TypeScript environments, this can be used to check that %%error%%\n *  matches an EthersError type, which means the expected properties will\n *  be set.\n *\n *  @See [ErrorCodes](api:ErrorCode)\n *  @example\n *    try {\n *      // code....\n *    } catch (e) {\n *      if (isError(e, \"CALL_EXCEPTION\")) {\n *          // The Type Guard has validated this object\n *          console.log(e.data);\n *      }\n *    }\n */\nexport function isError(error, code) {\n    return (error && error.code === code);\n}\n/**\n *  Returns true if %%error%% is a [[CallExceptionError].\n */\nexport function isCallException(error) {\n    return isError(error, \"CALL_EXCEPTION\");\n}\n/**\n *  Returns a new Error configured to the format ethers emits errors, with\n *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties\n *  for the corresponding EthersError.\n *\n *  Each error in ethers includes the version of ethers, a\n *  machine-readable [[ErrorCode]], and depending on %%code%%, additional\n *  required properties. The error message will also include the %%message%%,\n *  ethers version, %%code%% and all additional properties, serialized.\n */\nexport function makeError(message, code, info) {\n    let shortMessage = message;\n    {\n        const details = [];\n        if (info) {\n            if (\"message\" in info || \"code\" in info || \"name\" in info) {\n                throw new Error(`value will overwrite populated values: ${stringify(info)}`);\n            }\n            for (const key in info) {\n                if (key === \"shortMessage\") {\n                    continue;\n                }\n                const value = (info[key]);\n                //                try {\n                details.push(key + \"=\" + stringify(value));\n                //                } catch (error: any) {\n                //                console.log(\"MMM\", error.message);\n                //                    details.push(key + \"=[could not serialize object]\");\n                //                }\n            }\n        }\n        details.push(`code=${code}`);\n        details.push(`version=${version}`);\n        if (details.length) {\n            message += \" (\" + details.join(\", \") + \")\";\n        }\n    }\n    let error;\n    switch (code) {\n        case \"INVALID_ARGUMENT\":\n            error = new TypeError(message);\n            break;\n        case \"NUMERIC_FAULT\":\n        case \"BUFFER_OVERRUN\":\n            error = new RangeError(message);\n            break;\n        default:\n            error = new Error(message);\n    }\n    defineProperties(error, { code });\n    if (info) {\n        Object.assign(error, info);\n    }\n    if (error.shortMessage == null) {\n        defineProperties(error, { shortMessage });\n    }\n    return error;\n}\n/**\n *  Throws an EthersError with %%message%%, %%code%% and additional error\n *  %%info%% when %%check%% is falsish..\n *\n *  @see [[api:makeError]]\n */\nexport function assert(check, message, code, info) {\n    if (!check) {\n        throw makeError(message, code, info);\n    }\n}\n/**\n *  A simple helper to simply ensuring provided arguments match expected\n *  constraints, throwing if not.\n *\n *  In TypeScript environments, the %%check%% has been asserted true, so\n *  any further code does not need additional compile-time checks.\n */\nexport function assertArgument(check, message, name, value) {\n    assert(check, message, \"INVALID_ARGUMENT\", { argument: name, value: value });\n}\nexport function assertArgumentCount(count, expectedCount, message) {\n    if (message == null) {\n        message = \"\";\n    }\n    if (message) {\n        message = \": \" + message;\n    }\n    assert(count >= expectedCount, \"missing arguemnt\" + message, \"MISSING_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n    assert(count <= expectedCount, \"too many arguments\" + message, \"UNEXPECTED_ARGUMENT\", {\n        count: count,\n        expectedCount: expectedCount\n    });\n}\nconst _normalizeForms = [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].reduce((accum, form) => {\n    try {\n        // General test for normalize\n        /* c8 ignore start */\n        if (\"test\".normalize(form) !== \"test\") {\n            throw new Error(\"bad\");\n        }\n        ;\n        /* c8 ignore stop */\n        if (form === \"NFD\") {\n            const check = String.fromCharCode(0xe9).normalize(\"NFD\");\n            const expected = String.fromCharCode(0x65, 0x0301);\n            /* c8 ignore start */\n            if (check !== expected) {\n                throw new Error(\"broken\");\n            }\n            /* c8 ignore stop */\n        }\n        accum.push(form);\n    }\n    catch (error) { }\n    return accum;\n}, []);\n/**\n *  Throws if the normalization %%form%% is not supported.\n */\nexport function assertNormalize(form) {\n    assert(_normalizeForms.indexOf(form) >= 0, \"platform missing String.prototype.normalize\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"String.prototype.normalize\", info: { form }\n    });\n}\n/**\n *  Many classes use file-scoped values to guard the constructor,\n *  making it effectively private. This facilitates that pattern\n *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,\n *  throwing if not, indicating the %%className%% if provided.\n */\nexport function assertPrivate(givenGuard, guard, className) {\n    if (className == null) {\n        className = \"\";\n    }\n    if (givenGuard !== guard) {\n        let method = className, operation = \"new\";\n        if (className) {\n            method += \".\";\n            operation += \" \" + className;\n        }\n        assert(false, `private constructor; use ${method}from* methods`, \"UNSUPPORTED_OPERATION\", {\n            operation\n        });\n    }\n}\n//# sourceMappingURL=errors.js.map","/**\n *  Some data helpers.\n *\n *\n *  @_subsection api/utils:Data Helpers  [about-data]\n */\nimport { assert, assertArgument } from \"./errors.js\";\nfunction _getBytes(value, name, copy) {\n    if (value instanceof Uint8Array) {\n        if (copy) {\n            return new Uint8Array(value);\n        }\n        return value;\n    }\n    if (typeof (value) === \"string\" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {\n        const result = new Uint8Array((value.length - 2) / 2);\n        let offset = 2;\n        for (let i = 0; i < result.length; i++) {\n            result[i] = parseInt(value.substring(offset, offset + 2), 16);\n            offset += 2;\n        }\n        return result;\n    }\n    assertArgument(false, \"invalid BytesLike value\", name || \"value\", value);\n}\n/**\n *  Get a typed Uint8Array for %%value%%. If already a Uint8Array\n *  the original %%value%% is returned; if a copy is required use\n *  [[getBytesCopy]].\n *\n *  @see: getBytesCopy\n */\nexport function getBytes(value, name) {\n    return _getBytes(value, name, false);\n}\n/**\n *  Get a typed Uint8Array for %%value%%, creating a copy if necessary\n *  to prevent any modifications of the returned value from being\n *  reflected elsewhere.\n *\n *  @see: getBytes\n */\nexport function getBytesCopy(value, name) {\n    return _getBytes(value, name, true);\n}\n/**\n *  Returns true if %%value%% is a valid [[HexString]].\n *\n *  If %%length%% is ``true`` or a //number//, it also checks that\n *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)\n *  bytes of data (e.g. ``0x1234`` is 2 bytes).\n */\nexport function isHexString(value, length) {\n    if (typeof (value) !== \"string\" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n        return false;\n    }\n    if (typeof (length) === \"number\" && value.length !== 2 + 2 * length) {\n        return false;\n    }\n    if (length === true && (value.length % 2) !== 0) {\n        return false;\n    }\n    return true;\n}\n/**\n *  Returns true if %%value%% is a valid representation of arbitrary\n *  data (i.e. a valid [[DataHexString]] or a Uint8Array).\n */\nexport function isBytesLike(value) {\n    return (isHexString(value, true) || (value instanceof Uint8Array));\n}\nconst HexCharacters = \"0123456789abcdef\";\n/**\n *  Returns a [[DataHexString]] representation of %%data%%.\n */\nexport function hexlify(data) {\n    const bytes = getBytes(data);\n    let result = \"0x\";\n    for (let i = 0; i < bytes.length; i++) {\n        const v = bytes[i];\n        result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n    }\n    return result;\n}\n/**\n *  Returns a [[DataHexString]] by concatenating all values\n *  within %%data%%.\n */\nexport function concat(datas) {\n    return \"0x\" + datas.map((d) => hexlify(d).substring(2)).join(\"\");\n}\n/**\n *  Returns the length of %%data%%, in bytes.\n */\nexport function dataLength(data) {\n    if (isHexString(data, true)) {\n        return (data.length - 2) / 2;\n    }\n    return getBytes(data).length;\n}\n/**\n *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%\n *  offset to the %%end%% offset.\n *\n *  By default %%start%% is 0 and %%end%% is the length of %%data%%.\n */\nexport function dataSlice(data, start, end) {\n    const bytes = getBytes(data);\n    if (end != null && end > bytes.length) {\n        assert(false, \"cannot slice beyond data bounds\", \"BUFFER_OVERRUN\", {\n            buffer: bytes, length: bytes.length, offset: end\n        });\n    }\n    return hexlify(bytes.slice((start == null) ? 0 : start, (end == null) ? bytes.length : end));\n}\n/**\n *  Return the [[DataHexString]] result by stripping all **leading**\n ** zero bytes from %%data%%.\n */\nexport function stripZerosLeft(data) {\n    let bytes = hexlify(data).substring(2);\n    while (bytes.startsWith(\"00\")) {\n        bytes = bytes.substring(2);\n    }\n    return \"0x\" + bytes;\n}\nfunction zeroPad(data, length, left) {\n    const bytes = getBytes(data);\n    assert(length >= bytes.length, \"padding exceeds data length\", \"BUFFER_OVERRUN\", {\n        buffer: new Uint8Array(bytes),\n        length: length,\n        offset: length + 1\n    });\n    const result = new Uint8Array(length);\n    result.fill(0);\n    if (left) {\n        result.set(bytes, length - bytes.length);\n    }\n    else {\n        result.set(bytes, 0);\n    }\n    return hexlify(result);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **left**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **values** are in Solidity\n *  (e.g. ``uint128``).\n */\nexport function zeroPadValue(data, length) {\n    return zeroPad(data, length, true);\n}\n/**\n *  Return the [[DataHexString]] of %%data%% padded on the **right**\n *  to %%length%% bytes.\n *\n *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is\n *  thrown.\n *\n *  This pads data the same as **bytes** are in Solidity\n *  (e.g. ``bytes16``).\n */\nexport function zeroPadBytes(data, length) {\n    return zeroPad(data, length, false);\n}\n//# sourceMappingURL=data.js.map","/**\n *  Some mathematic operations.\n *\n *  @_subsection: api/utils:Math Helpers  [about-maths]\n */\nimport { hexlify, isBytesLike } from \"./data.js\";\nimport { assert, assertArgument } from \"./errors.js\";\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\n//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;\n// IEEE 754 support 53-bits of mantissa\nconst maxValue = 0x1fffffffffffff;\n/**\n *  Convert %%value%% from a twos-compliment representation of %%width%%\n *  bits to its value.\n *\n *  If the highest bit is ``1``, the result will be negative.\n */\nexport function fromTwos(_value, _width) {\n    const value = getUint(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    assert((value >> width) === BN_0, \"overflow\", \"NUMERIC_FAULT\", {\n        operation: \"fromTwos\", fault: \"overflow\", value: _value\n    });\n    // Top bit set; treat as a negative value\n    if (value >> (width - BN_1)) {\n        const mask = (BN_1 << width) - BN_1;\n        return -(((~value) & mask) + BN_1);\n    }\n    return value;\n}\n/**\n *  Convert %%value%% to a twos-compliment representation of\n *  %%width%% bits.\n *\n *  The result will always be positive.\n */\nexport function toTwos(_value, _width) {\n    let value = getBigInt(_value, \"value\");\n    const width = BigInt(getNumber(_width, \"width\"));\n    const limit = (BN_1 << (width - BN_1));\n    if (value < BN_0) {\n        value = -value;\n        assert(value <= limit, \"too low\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n        const mask = (BN_1 << width) - BN_1;\n        return ((~value) & mask) + BN_1;\n    }\n    else {\n        assert(value < limit, \"too high\", \"NUMERIC_FAULT\", {\n            operation: \"toTwos\", fault: \"overflow\", value: _value\n        });\n    }\n    return value;\n}\n/**\n *  Mask %%value%% with a bitmask of %%bits%% ones.\n */\nexport function mask(_value, _bits) {\n    const value = getUint(_value, \"value\");\n    const bits = BigInt(getNumber(_bits, \"bits\"));\n    return value & ((BN_1 << bits) - BN_1);\n}\n/**\n *  Gets a BigInt from %%value%%. If it is an invalid value for\n *  a BigInt, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getBigInt(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\": return value;\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return BigInt(value);\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                if (value[0] === \"-\" && value[1] !== \"-\") {\n                    return -BigInt(value.substring(1));\n                }\n                return BigInt(value);\n            }\n            catch (e) {\n                assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid BigNumberish value\", name || \"value\", value);\n}\n/**\n *  Returns %%value%% as a bigint, validating it is valid as a bigint\n *  value and that it is positive.\n */\nexport function getUint(value, name) {\n    const result = getBigInt(value, name);\n    assert(result >= BN_0, \"unsigned value cannot be negative\", \"NUMERIC_FAULT\", {\n        fault: \"overflow\", operation: \"getUint\", value\n    });\n    return result;\n}\nconst Nibbles = \"0123456789abcdef\";\n/*\n * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it\n * is treated as Big Endian data.\n */\nexport function toBigInt(value) {\n    if (value instanceof Uint8Array) {\n        let result = \"0x0\";\n        for (const v of value) {\n            result += Nibbles[v >> 4];\n            result += Nibbles[v & 0x0f];\n        }\n        return BigInt(result);\n    }\n    return getBigInt(value);\n}\n/**\n *  Gets a //number// from %%value%%. If it is an invalid value for\n *  a //number//, then an ArgumentError will be thrown for %%name%%.\n */\nexport function getNumber(value, name) {\n    switch (typeof (value)) {\n        case \"bigint\":\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return Number(value);\n        case \"number\":\n            assertArgument(Number.isInteger(value), \"underflow\", name || \"value\", value);\n            assertArgument(value >= -maxValue && value <= maxValue, \"overflow\", name || \"value\", value);\n            return value;\n        case \"string\":\n            try {\n                if (value === \"\") {\n                    throw new Error(\"empty string\");\n                }\n                return getNumber(BigInt(value), name);\n            }\n            catch (e) {\n                assertArgument(false, `invalid numeric string: ${e.message}`, name || \"value\", value);\n            }\n    }\n    assertArgument(false, \"invalid numeric value\", name || \"value\", value);\n}\n/**\n *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it\n *  is treated as Big Endian data. Throws if the value is not safe.\n */\nexport function toNumber(value) {\n    return getNumber(toBigInt(value));\n}\n/**\n *  Converts %%value%% to a Big Endian hexstring, optionally padded to\n *  %%width%% bytes.\n */\nexport function toBeHex(_value, _width) {\n    const value = getUint(_value, \"value\");\n    let result = value.toString(16);\n    if (_width == null) {\n        // Ensure the value is of even length\n        if (result.length % 2) {\n            result = \"0\" + result;\n        }\n    }\n    else {\n        const width = getNumber(_width, \"width\");\n        assert(width * 2 >= result.length, `value exceeds width (${width} bytes)`, \"NUMERIC_FAULT\", {\n            operation: \"toBeHex\",\n            fault: \"overflow\",\n            value: _value\n        });\n        // Pad the value to the required width\n        while (result.length < (width * 2)) {\n            result = \"0\" + result;\n        }\n    }\n    return \"0x\" + result;\n}\n/**\n *  Converts %%value%% to a Big Endian Uint8Array.\n */\nexport function toBeArray(_value) {\n    const value = getUint(_value, \"value\");\n    if (value === BN_0) {\n        return new Uint8Array([]);\n    }\n    let hex = value.toString(16);\n    if (hex.length % 2) {\n        hex = \"0\" + hex;\n    }\n    const result = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < result.length; i++) {\n        const offset = i * 2;\n        result[i] = parseInt(hex.substring(offset, offset + 2), 16);\n    }\n    return result;\n}\n/**\n *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.\n *\n *  A //Quantity// does not have and leading 0 values unless the value is\n *  the literal value `0x0`. This is most commonly used for JSSON-RPC\n *  numeric values.\n */\nexport function toQuantity(value) {\n    let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);\n    while (result.startsWith(\"0\")) {\n        result = result.substring(1);\n    }\n    if (result === \"\") {\n        result = \"0\";\n    }\n    return \"0x\" + result;\n}\n//# sourceMappingURL=maths.js.map","/**\n *  Events allow for applications to use the observer pattern, which\n *  allows subscribing and publishing events, outside the normal\n *  execution paths.\n *\n *  @_section api/utils/events:Events  [about-events]\n */\nimport { defineProperties } from \"./properties.js\";\n/**\n *  When an [[EventEmitterable]] triggers a [[Listener]], the\n *  callback always ahas one additional argument passed, which is\n *  an **EventPayload**.\n */\nexport class EventPayload {\n    /**\n     *  The event filter.\n     */\n    filter;\n    /**\n     *  The **EventEmitterable**.\n     */\n    emitter;\n    #listener;\n    /**\n     *  Create a new **EventPayload** for %%emitter%% with\n     *  the %%listener%% and for %%filter%%.\n     */\n    constructor(emitter, listener, filter) {\n        this.#listener = listener;\n        defineProperties(this, { emitter, filter });\n    }\n    /**\n     *  Unregister the triggered listener for future events.\n     */\n    async removeListener() {\n        if (this.#listener == null) {\n            return;\n        }\n        await this.emitter.off(this.filter, this.#listener);\n    }\n}\n//# sourceMappingURL=events.js.map","/**\n *  Using strings in Ethereum (or any security-basd system) requires\n *  additional care. These utilities attempt to mitigate some of the\n *  safety issues as well as provide the ability to recover and analyse\n *  strings.\n *\n *  @_subsection api/utils:Strings and UTF-8  [about-strings]\n */\nimport { getBytes } from \"./data.js\";\nimport { assertArgument, assertNormalize } from \"./errors.js\";\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === \"BAD_PREFIX\" || reason === \"UNEXPECTED_CONTINUE\") {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === \"OVERRUN\") {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === \"OVERLONG\") {\n        assertArgument(typeof (badCodepoint) === \"number\", \"invalid bad code point for replacement\", \"badCodepoint\", badCodepoint);\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n/**\n *  A handful of popular, built-in UTF-8 error handling strategies.\n *\n *  **``\"error\"``** - throws on ANY illegal UTF-8 sequence or\n *  non-canonical (overlong) codepoints (this is the default)\n *\n *  **``\"ignore\"``** - silently drops any illegal UTF-8 sequence\n *  and accepts non-canonical (overlong) codepoints\n *\n *  **``\"replace\"``** - replace any illegal UTF-8 sequence with the\n *  UTF-8 replacement character (i.e. ``\"\\\\ufffd\"``) and accepts\n *  non-canonical (overlong) codepoints\n *\n *  @returns: Record<\"error\" | \"ignore\" | \"replace\", Utf8ErrorFunc>\n */\nexport const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(_bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    const bytes = getBytes(_bytes, \"bytes\");\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(\"UNEXPECTED_CONTINUE\", i - 1, bytes, result);\n            }\n            else {\n                i += onError(\"BAD_PREFIX\", i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(\"OVERRUN\", i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(\"MISSING_CONTINUE\", i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(\"OUT_OF_RANGE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(\"UTF16_SURROGATE\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(\"OVERLONG\", i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n/**\n *  Returns the UTF-8 byte representation of %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8Bytes(str, form) {\n    assertArgument(typeof (str) === \"string\", \"invalid string value\", \"str\", str);\n    if (form != null) {\n        assertNormalize(form);\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            assertArgument(i < str.length && ((c2 & 0xfc00) === 0xdc00), \"invalid surrogate pair\", \"str\", str);\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return new Uint8Array(result);\n}\n;\n//export \nfunction _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\n/**\n *  Returns the string represented by the UTF-8 data %%bytes%%.\n *\n *  When %%onError%% function is specified, it is called on UTF-8\n *  errors allowing recovery using the [[Utf8ErrorFunc]] API.\n *  (default: [error](Utf8ErrorFuncs))\n */\nexport function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\n/**\n *  Returns the UTF-8 code-points for %%str%%.\n *\n *  If %%form%% is specified, the string is normalized.\n */\nexport function toUtf8CodePoints(str, form) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map","/**\n *  The **FixedNumber** class permits using values with decimal places,\n *  using fixed-pont math.\n *\n *  Fixed-point math is still based on integers under-the-hood, but uses an\n *  internal offset to store fractional components below, and each operation\n *  corrects for this after each operation.\n *\n *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]\n */\nimport { getBytes } from \"./data.js\";\nimport { assert, assertArgument, assertPrivate } from \"./errors.js\";\nimport { getBigInt, getNumber, fromTwos, mask, toBigInt } from \"./maths.js\";\nimport { defineProperties } from \"./properties.js\";\nconst BN_N1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_5 = BigInt(5);\nconst _guard = {};\n// Constant to pull zeros from for multipliers\nlet Zeros = \"0000\";\nwhile (Zeros.length < 80) {\n    Zeros += Zeros;\n}\n// Returns a string \"1\" followed by decimal \"0\"s\nfunction getTens(decimals) {\n    let result = Zeros;\n    while (result.length < decimals) {\n        result += result;\n    }\n    return BigInt(\"1\" + result.substring(0, decimals));\n}\nfunction checkValue(val, format, safeOp) {\n    const width = BigInt(format.width);\n    if (format.signed) {\n        const limit = (BN_1 << (width - BN_1));\n        assert(safeOp == null || (val >= -limit && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        if (val > BN_0) {\n            val = fromTwos(mask(val, width), width);\n        }\n        else {\n            val = -fromTwos(mask(-val, width), width);\n        }\n    }\n    else {\n        const limit = (BN_1 << width);\n        assert(safeOp == null || (val >= 0 && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n            operation: safeOp, fault: \"overflow\", value: val\n        });\n        val = (((val % limit) + limit) % limit) & (limit - BN_1);\n    }\n    return val;\n}\nfunction getFormat(value) {\n    if (typeof (value) === \"number\") {\n        value = `fixed128x${value}`;\n    }\n    let signed = true;\n    let width = 128;\n    let decimals = 18;\n    if (typeof (value) === \"string\") {\n        // Parse the format string\n        if (value === \"fixed\") {\n            // defaults...\n        }\n        else if (value === \"ufixed\") {\n            signed = false;\n        }\n        else {\n            const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n            assertArgument(match, \"invalid fixed format\", \"format\", value);\n            signed = (match[1] !== \"u\");\n            width = parseInt(match[2]);\n            decimals = parseInt(match[3]);\n        }\n    }\n    else if (value) {\n        // Extract the values from the object\n        const v = value;\n        const check = (key, type, defaultValue) => {\n            if (v[key] == null) {\n                return defaultValue;\n            }\n            assertArgument(typeof (v[key]) === type, \"invalid fixed format (\" + key + \" not \" + type + \")\", \"format.\" + key, v[key]);\n            return v[key];\n        };\n        signed = check(\"signed\", \"boolean\", signed);\n        width = check(\"width\", \"number\", width);\n        decimals = check(\"decimals\", \"number\", decimals);\n    }\n    assertArgument((width % 8) === 0, \"invalid FixedNumber width (not byte aligned)\", \"format.width\", width);\n    assertArgument(decimals <= 80, \"invalid FixedNumber decimals (too large)\", \"format.decimals\", decimals);\n    const name = (signed ? \"\" : \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\n    return { signed, width, decimals, name };\n}\nfunction toString(val, decimals) {\n    let negative = \"\";\n    if (val < BN_0) {\n        negative = \"-\";\n        val *= BN_N1;\n    }\n    let str = val.toString();\n    // No decimal point for whole values\n    if (decimals === 0) {\n        return (negative + str);\n    }\n    // Pad out to the whole component (including a whole digit)\n    while (str.length <= decimals) {\n        str = Zeros + str;\n    }\n    // Insert the decimal point\n    const index = str.length - decimals;\n    str = str.substring(0, index) + \".\" + str.substring(index);\n    // Trim the whole component (leaving at least one 0)\n    while (str[0] === \"0\" && str[1] !== \".\") {\n        str = str.substring(1);\n    }\n    // Trim the decimal component (leaving at least one 0)\n    while (str[str.length - 1] === \"0\" && str[str.length - 2] !== \".\") {\n        str = str.substring(0, str.length - 1);\n    }\n    return (negative + str);\n}\n/**\n *  A FixedNumber represents a value over its [[FixedFormat]]\n *  arithmetic field.\n *\n *  A FixedNumber can be used to perform math, losslessly, on\n *  values which have decmial places.\n *\n *  A FixedNumber has a fixed bit-width to store values in, and stores all\n *  values internally by multiplying the value by 10 raised to the power of\n *  %%decimals%%.\n *\n *  If operations are performed that cause a value to grow too high (close to\n *  positive infinity) or too low (close to negative infinity), the value\n *  is said to //overflow//.\n *\n *  For example, an 8-bit signed value, with 0 decimals may only be within\n *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become\n *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.\n *\n *  Many operation have a normal and //unsafe// variant. The normal variant\n *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//\n *  variant will silently allow overflow, corrupting its value value.\n *\n *  If operations are performed that cause a value to become too small\n *  (close to zero), the value loses precison and is said to //underflow//.\n *\n *  For example, an value with 1 decimal place may store a number as small\n *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit\n *  into 1 decimal place, so underflow occurs which means precision is lost\n *  and the value becomes ``0``.\n *\n *  Some operations have a normal and //signalling// variant. The normal\n *  variant will silently ignore underflow, while the //signalling// variant\n *  will thow a [[NumericFaultError]] on underflow.\n */\nexport class FixedNumber {\n    /**\n     *  The specific fixed-point arithmetic field for this value.\n     */\n    format;\n    #format;\n    // The actual value (accounting for decimals)\n    #val;\n    // A base-10 value to multiple values by to maintain the magnitude\n    #tens;\n    /**\n     *  This is a property so console.log shows a human-meaningful value.\n     *\n     *  @private\n     */\n    _value;\n    // Use this when changing this file to get some typing info,\n    // but then switch to any to mask the internal type\n    //constructor(guard: any, value: bigint, format: _FixedFormat) {\n    /**\n     *  @private\n     */\n    constructor(guard, value, format) {\n        assertPrivate(guard, _guard, \"FixedNumber\");\n        this.#val = value;\n        this.#format = format;\n        const _value = toString(value, format.decimals);\n        defineProperties(this, { format: format.name, _value });\n        this.#tens = getTens(format.decimals);\n    }\n    /**\n     *  If true, negative values are permitted, otherwise only\n     *  positive values and zero are allowed.\n     */\n    get signed() { return this.#format.signed; }\n    /**\n     *  The number of bits available to store the value.\n     */\n    get width() { return this.#format.width; }\n    /**\n     *  The number of decimal places in the fixed-point arithment field.\n     */\n    get decimals() { return this.#format.decimals; }\n    /**\n     *  The value as an integer, based on the smallest unit the\n     *  [[decimals]] allow.\n     */\n    get value() { return this.#val; }\n    #checkFormat(other) {\n        assertArgument(this.format === other.format, \"incompatible format; use fixedNumber.toFormat\", \"other\", other);\n    }\n    #checkValue(val, safeOp) {\n        /*\n                const width = BigInt(this.width);\n                if (this.signed) {\n                    const limit = (BN_1 << (width - BN_1));\n                    assert(safeOp == null || (val >= -limit  && val < limit), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n        \n                    if (val > BN_0) {\n                        val = fromTwos(mask(val, width), width);\n                    } else {\n                        val = -fromTwos(mask(-val, width), width);\n                    }\n        \n                } else {\n                    const masked = mask(val, width);\n                    assert(safeOp == null || (val >= 0 && val === masked), \"overflow\", \"NUMERIC_FAULT\", {\n                        operation: <string>safeOp, fault: \"overflow\", value: val\n                    });\n                    val = masked;\n                }\n        */\n        val = checkValue(val, this.#format, safeOp);\n        return new FixedNumber(_guard, val, this.#format);\n    }\n    #add(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val + o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%, ignoring overflow.\n     */\n    addUnsafe(other) { return this.#add(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% added\n     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    add(other) { return this.#add(other, \"add\"); }\n    #sub(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue(this.#val - o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%, ignoring overflow.\n     */\n    subUnsafe(other) { return this.#sub(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted\n     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    sub(other) { return this.#sub(other, \"sub\"); }\n    #mul(o, safeOp) {\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%, ignoring overflow and underflow (precision loss).\n     */\n    mulUnsafe(other) { return this.#mul(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs.\n     */\n    mul(other) { return this.#mul(other, \"mul\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied\n     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow\n     *  occurs or if underflow (precision loss) occurs.\n     */\n    mulSignal(other) {\n        this.#checkFormat(other);\n        const value = this.#val * other.#val;\n        assert((value % this.#tens) === BN_0, \"precision lost during signalling mul\", \"NUMERIC_FAULT\", {\n            operation: \"mulSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / this.#tens, \"mulSignal\");\n    }\n    #div(o, safeOp) {\n        assert(o.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(o);\n        return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    divUnsafe(other) { return this.#div(other); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%, ignoring underflow (precision loss). A\n     *  [[NumericFaultError]] is thrown if overflow occurs.\n     */\n    div(other) { return this.#div(other, \"div\"); }\n    /**\n     *  Returns a new [[FixedNumber]] with the result of %%this%% divided\n     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow\n     *  (precision loss) occurs.\n     */\n    divSignal(other) {\n        assert(other.#val !== BN_0, \"division by zero\", \"NUMERIC_FAULT\", {\n            operation: \"div\", fault: \"divide-by-zero\", value: this\n        });\n        this.#checkFormat(other);\n        const value = (this.#val * this.#tens);\n        assert((value % other.#val) === BN_0, \"precision lost during signalling div\", \"NUMERIC_FAULT\", {\n            operation: \"divSignal\", fault: \"underflow\", value: this\n        });\n        return this.#checkValue(value / other.#val, \"divSignal\");\n    }\n    /**\n     *  Returns a comparison result between %%this%% and %%other%%.\n     *\n     *  This is suitable for use in sorting, where ``-1`` implies %%this%%\n     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies\n     *  both are equal.\n     */\n    cmp(other) {\n        let a = this.value, b = other.value;\n        // Coerce a and b to the same magnitude\n        const delta = this.decimals - other.decimals;\n        if (delta > 0) {\n            b *= getTens(delta);\n        }\n        else if (delta < 0) {\n            a *= getTens(-delta);\n        }\n        // Comnpare\n        if (a < b) {\n            return -1;\n        }\n        if (a > b) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     *  Returns true if %%other%% is equal to %%this%%.\n     */\n    eq(other) { return this.cmp(other) === 0; }\n    /**\n     *  Returns true if %%other%% is less than to %%this%%.\n     */\n    lt(other) { return this.cmp(other) < 0; }\n    /**\n     *  Returns true if %%other%% is less than or equal to %%this%%.\n     */\n    lte(other) { return this.cmp(other) <= 0; }\n    /**\n     *  Returns true if %%other%% is greater than to %%this%%.\n     */\n    gt(other) { return this.cmp(other) > 0; }\n    /**\n     *  Returns true if %%other%% is greater than or equal to %%this%%.\n     */\n    gte(other) { return this.cmp(other) >= 0; }\n    /**\n     *  Returns a new [[FixedNumber]] which is the largest **integer**\n     *  that is less than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    floor() {\n        let val = this.#val;\n        if (this.#val < BN_0) {\n            val -= this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"floor\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] which is the smallest **integer**\n     *  that is greater than or equal to %%this%%.\n     *\n     *  The decimal component of the result will always be ``0``.\n     */\n    ceiling() {\n        let val = this.#val;\n        if (this.#val > BN_0) {\n            val += this.#tens - BN_1;\n        }\n        val = (this.#val / this.#tens) * this.#tens;\n        return this.#checkValue(val, \"ceiling\");\n    }\n    /**\n     *  Returns a new [[FixedNumber]] with the decimal component\n     *  rounded up on ties at %%decimals%% places.\n     */\n    round(decimals) {\n        if (decimals == null) {\n            decimals = 0;\n        }\n        // Not enough precision to not already be rounded\n        if (decimals >= this.decimals) {\n            return this;\n        }\n        const delta = this.decimals - decimals;\n        const bump = BN_5 * getTens(delta - 1);\n        let value = this.value + bump;\n        const tens = getTens(delta);\n        value = (value / tens) * tens;\n        checkValue(value, this.#format, \"round\");\n        return new FixedNumber(_guard, value, this.#format);\n    }\n    /**\n     *  Returns true if %%this%% is equal to ``0``.\n     */\n    isZero() { return (this.#val === BN_0); }\n    /**\n     *  Returns true if %%this%% is less than ``0``.\n     */\n    isNegative() { return (this.#val < BN_0); }\n    /**\n     *  Returns the string representation of %%this%%.\n     */\n    toString() { return this._value; }\n    /**\n     *  Returns a float approximation.\n     *\n     *  Due to IEEE 754 precission (or lack thereof), this function\n     *  can only return an approximation and most values will contain\n     *  rounding errors.\n     */\n    toUnsafeFloat() { return parseFloat(this.toString()); }\n    /**\n     *  Return a new [[FixedNumber]] with the same value but has had\n     *  its field set to %%format%%.\n     *\n     *  This will throw if the value cannot fit into %%format%%.\n     */\n    toFormat(format) {\n        return FixedNumber.fromString(this.toString(), format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% divided by\n     *  %%decimal%% places with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted\n     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow\n     *  or underflow (precision loss).\n     */\n    static fromValue(_value, _decimals, _format) {\n        const decimals = (_decimals == null) ? 0 : getNumber(_decimals);\n        const format = getFormat(_format);\n        let value = getBigInt(_value, \"value\");\n        const delta = decimals - format.decimals;\n        if (delta > 0) {\n            const tens = getTens(delta);\n            assert((value % tens) === BN_0, \"value loses precision for format\", \"NUMERIC_FAULT\", {\n                operation: \"fromValue\", fault: \"underflow\", value: _value\n            });\n            value /= tens;\n        }\n        else if (delta < 0) {\n            value *= getTens(-delta);\n        }\n        checkValue(value, format, \"fromValue\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%%, either due to overflow or underflow (precision loss).\n     */\n    static fromString(_value, _format) {\n        const match = _value.match(/^(-?)([0-9]*)\\.?([0-9]*)$/);\n        assertArgument(match && (match[2].length + match[3].length) > 0, \"invalid FixedNumber string value\", \"value\", _value);\n        const format = getFormat(_format);\n        let whole = (match[2] || \"0\"), decimal = (match[3] || \"\");\n        // Pad out the decimals\n        while (decimal.length < format.decimals) {\n            decimal += Zeros;\n        }\n        // Check precision is safe\n        assert(decimal.substring(format.decimals).match(/^0*$/), \"too many decimals for format\", \"NUMERIC_FAULT\", {\n            operation: \"fromString\", fault: \"underflow\", value: _value\n        });\n        // Remove extra padding\n        decimal = decimal.substring(0, format.decimals);\n        const value = BigInt(match[1] + whole + decimal);\n        checkValue(value, format, \"fromString\");\n        return new FixedNumber(_guard, value, format);\n    }\n    /**\n     *  Creates a new [[FixedNumber]] with the big-endian representation\n     *  %%value%% with %%format%%.\n     *\n     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit\n     *  in %%format%% due to overflow.\n     */\n    static fromBytes(_value, _format) {\n        let value = toBigInt(getBytes(_value, \"value\"));\n        const format = getFormat(_format);\n        if (format.signed) {\n            value = fromTwos(value, format.width);\n        }\n        checkValue(value, format, \"fromBytes\");\n        return new FixedNumber(_guard, value, format);\n    }\n}\n//const f1 = FixedNumber.fromString(\"12.56\", \"fixed16x2\");\n//const f2 = FixedNumber.fromString(\"0.3\", \"fixed16x2\");\n//console.log(f1.divSignal(f2));\n//const BUMP = FixedNumber.from(\"0.5\");\n//# sourceMappingURL=fixednumber.js.map","/**\n *  Most interactions with Ethereum requires integer values, which use\n *  the smallest magnitude unit.\n *\n *  For example, imagine dealing with dollars and cents. Since dollars\n *  are divisible, non-integer values are possible, such as ``$10.77``.\n *  By using the smallest indivisible unit (i.e. cents), the value can\n *  be kept as the integer ``1077``.\n *\n *  When receiving decimal input from the user (as a decimal string),\n *  the value should be converted to an integer and when showing a user\n *  a value, the integer value should be converted to a decimal string.\n *\n *  This creates a clear distinction, between values to be used by code\n *  (integers) and values used for display logic to users (decimals).\n *\n *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,\n *  where each individual unit is called a //wei//.\n *\n *  @_subsection api/utils:Unit Conversion  [about-units]\n */\nimport { assertArgument } from \"./errors.js\";\nimport { FixedNumber } from \"./fixednumber.js\";\nimport { getNumber } from \"./maths.js\";\nconst names = [\n    \"wei\",\n    \"kwei\",\n    \"mwei\",\n    \"gwei\",\n    \"szabo\",\n    \"finney\",\n    \"ether\",\n];\n/**\n *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal\n *  places. The %%unit%% may be the number of decimal places or the name of\n *  a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n *\n */\nexport function formatUnits(value, unit) {\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n    return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();\n}\n/**\n *  Converts the //decimal string// %%value%% to a BigInt, assuming\n *  %%unit%% decimal places. The %%unit%% may the number of decimal places\n *  or the name of a unit (e.g. ``\"gwei\"`` for 9 decimal places).\n */\nexport function parseUnits(value, unit) {\n    assertArgument(typeof (value) === \"string\", \"value must be a string\", \"value\", value);\n    let decimals = 18;\n    if (typeof (unit) === \"string\") {\n        const index = names.indexOf(unit);\n        assertArgument(index >= 0, \"invalid unit\", \"unit\", unit);\n        decimals = 3 * index;\n    }\n    else if (unit != null) {\n        decimals = getNumber(unit, \"unit\");\n    }\n    return FixedNumber.fromString(value, { decimals, width: 512 }).value;\n}\n/**\n *  Converts %%value%% into a //decimal string// using 18 decimal places.\n */\nexport function formatEther(wei) {\n    return formatUnits(wei, 18);\n}\n/**\n *  Converts the //decimal string// %%ether%% to a BigInt, using 18\n *  decimal places.\n */\nexport function parseEther(ether) {\n    return parseUnits(ether, 18);\n}\n//# sourceMappingURL=units.js.map","import { defineProperties, concat, getBytesCopy, getNumber, hexlify, toBeArray, toBigInt, toNumber, assert, assertArgument\n/*, isError*/\n } from \"../../utils/index.js\";\n/**\n * @_ignore:\n */\nexport const WordSize = 32;\nconst Padding = new Uint8Array(WordSize);\n// Properties used to immediate pass through to the underlying object\n// - `then` is used to detect if an object is a Promise for await\nconst passProperties = [\"then\"];\nconst _guard = {};\nconst resultNames = new WeakMap();\nfunction getNames(result) {\n    return resultNames.get(result);\n}\nfunction setNames(result, names) {\n    resultNames.set(result, names);\n}\nfunction throwError(name, error) {\n    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);\n    wrapped.error = error;\n    throw wrapped;\n}\nfunction toObject(names, items, deep) {\n    if (names.indexOf(null) >= 0) {\n        return items.map((item, index) => {\n            if (item instanceof Result) {\n                return toObject(getNames(item), item, deep);\n            }\n            return item;\n        });\n    }\n    return names.reduce((accum, name, index) => {\n        let item = items.getValue(name);\n        if (!(name in accum)) {\n            if (deep && item instanceof Result) {\n                item = toObject(getNames(item), item, deep);\n            }\n            accum[name] = item;\n        }\n        return accum;\n    }, {});\n}\n/**\n *  A [[Result]] is a sub-class of Array, which allows accessing any\n *  of its values either positionally by its index or, if keys are\n *  provided by its name.\n *\n *  @_docloc: api/abi\n */\nexport class Result extends Array {\n    // No longer used; but cannot be removed as it will remove the\n    // #private field from the .d.ts which may break backwards\n    // compatibility\n    #names;\n    /**\n     *  @private\n     */\n    constructor(...args) {\n        // To properly sub-class Array so the other built-in\n        // functions work, the constructor has to behave fairly\n        // well. So, in the event we are created via fromItems()\n        // we build the read-only Result object we want, but on\n        // any other input, we use the default constructor\n        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);\n        const guard = args[0];\n        let items = args[1];\n        let names = (args[2] || []).slice();\n        let wrap = true;\n        if (guard !== _guard) {\n            items = args;\n            names = [];\n            wrap = false;\n        }\n        // Can't just pass in ...items since an array of length 1\n        // is a special case in the super.\n        super(items.length);\n        items.forEach((item, index) => { this[index] = item; });\n        // Find all unique keys\n        const nameCounts = names.reduce((accum, name) => {\n            if (typeof (name) === \"string\") {\n                accum.set(name, (accum.get(name) || 0) + 1);\n            }\n            return accum;\n        }, (new Map()));\n        // Remove any key thats not unique\n        setNames(this, Object.freeze(items.map((item, index) => {\n            const name = names[index];\n            if (name != null && nameCounts.get(name) === 1) {\n                return name;\n            }\n            return null;\n        })));\n        // Dummy operations to prevent TypeScript from complaining\n        this.#names = [];\n        if (this.#names == null) {\n            void (this.#names);\n        }\n        if (!wrap) {\n            return;\n        }\n        // A wrapped Result is immutable\n        Object.freeze(this);\n        // Proxy indices and names so we can trap deferred errors\n        const proxy = new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"string\") {\n                    // Index accessor\n                    if (prop.match(/^[0-9]+$/)) {\n                        const index = getNumber(prop, \"%index\");\n                        if (index < 0 || index >= this.length) {\n                            throw new RangeError(\"out of result range\");\n                        }\n                        const item = target[index];\n                        if (item instanceof Error) {\n                            throwError(`index ${index}`, item);\n                        }\n                        return item;\n                    }\n                    // Pass important checks (like `then` for Promise) through\n                    if (passProperties.indexOf(prop) >= 0) {\n                        return Reflect.get(target, prop, receiver);\n                    }\n                    const value = target[prop];\n                    if (value instanceof Function) {\n                        // Make sure functions work with private variables\n                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding\n                        return function (...args) {\n                            return value.apply((this === receiver) ? target : this, args);\n                        };\n                    }\n                    else if (!(prop in target)) {\n                        // Possible name accessor\n                        return target.getValue.apply((this === receiver) ? target : this, [prop]);\n                    }\n                }\n                return Reflect.get(target, prop, receiver);\n            }\n        });\n        setNames(proxy, getNames(this));\n        return proxy;\n    }\n    /**\n     *  Returns the Result as a normal Array. If %%deep%%, any children\n     *  which are Result objects are also converted to a normal Array.\n     *\n     *  This will throw if there are any outstanding deferred\n     *  errors.\n     */\n    toArray(deep) {\n        const result = [];\n        this.forEach((item, index) => {\n            if (item instanceof Error) {\n                throwError(`index ${index}`, item);\n            }\n            if (deep && item instanceof Result) {\n                item = item.toArray(deep);\n            }\n            result.push(item);\n        });\n        return result;\n    }\n    /**\n     *  Returns the Result as an Object with each name-value pair. If\n     *  %%deep%%, any children which are Result objects are also\n     *  converted to an Object.\n     *\n     *  This will throw if any value is unnamed, or if there are\n     *  any outstanding deferred errors.\n     */\n    toObject(deep) {\n        const names = getNames(this);\n        return names.reduce((accum, name, index) => {\n            assert(name != null, `value at index ${index} unnamed`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"toObject()\"\n            });\n            return toObject(names, this, deep);\n        }, {});\n    }\n    /**\n     *  @_ignore\n     */\n    slice(start, end) {\n        if (start == null) {\n            start = 0;\n        }\n        if (start < 0) {\n            start += this.length;\n            if (start < 0) {\n                start = 0;\n            }\n        }\n        if (end == null) {\n            end = this.length;\n        }\n        if (end < 0) {\n            end += this.length;\n            if (end < 0) {\n                end = 0;\n            }\n        }\n        if (end > this.length) {\n            end = this.length;\n        }\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = start; i < end; i++) {\n            result.push(this[i]);\n            names.push(_names[i]);\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    filter(callback, thisArg) {\n        const _names = getNames(this);\n        const result = [], names = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            if (callback.call(thisArg, item, i, this)) {\n                result.push(item);\n                names.push(_names[i]);\n            }\n        }\n        return new Result(_guard, result, names);\n    }\n    /**\n     *  @_ignore\n     */\n    map(callback, thisArg) {\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            const item = this[i];\n            if (item instanceof Error) {\n                throwError(`index ${i}`, item);\n            }\n            result.push(callback.call(thisArg, item, i, this));\n        }\n        return result;\n    }\n    /**\n     *  Returns the value for %%name%%.\n     *\n     *  Since it is possible to have a key whose name conflicts with\n     *  a method on a [[Result]] or its superclass Array, or any\n     *  JavaScript keyword, this ensures all named values are still\n     *  accessible by name.\n     */\n    getValue(name) {\n        const index = getNames(this).indexOf(name);\n        if (index === -1) {\n            return undefined;\n        }\n        const value = this[index];\n        if (value instanceof Error) {\n            throwError(`property ${JSON.stringify(name)}`, value.error);\n        }\n        return value;\n    }\n    /**\n     *  Creates a new [[Result]] for %%items%% with each entry\n     *  also accessible by its corresponding name in %%keys%%.\n     */\n    static fromItems(items, keys) {\n        return new Result(_guard, items, keys);\n    }\n}\n/**\n *  Returns all errors found in a [[Result]].\n *\n *  Since certain errors encountered when creating a [[Result]] do\n *  not impact the ability to continue parsing data, they are\n *  deferred until they are actually accessed. Hence a faulty string\n *  in an Event that is never used does not impact the program flow.\n *\n *  However, sometimes it may be useful to access, identify or\n *  validate correctness of a [[Result]].\n *\n *  @_docloc api/abi\n */\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nfunction getValue(value) {\n    let bytes = toBeArray(value);\n    assert(bytes.length <= WordSize, \"value out-of-bounds\", \"BUFFER_OVERRUN\", { buffer: bytes, length: WordSize, offset: bytes.length });\n    if (bytes.length !== WordSize) {\n        bytes = getBytesCopy(concat([Padding.slice(bytes.length % WordSize), bytes]));\n    }\n    return bytes;\n}\n/**\n *  @_ignore\n */\nexport class Coder {\n    // The coder name:\n    //   - address, uint256, tuple, array, etc.\n    name;\n    // The fully expanded type, including composite types:\n    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.\n    type;\n    // The localName bound in the signature, in this example it is \"baz\":\n    //   - tuple(address foo, uint bar) baz\n    localName;\n    // Whether this type is dynamic:\n    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.\n    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)\n    dynamic;\n    constructor(name, type, localName, dynamic) {\n        defineProperties(this, { name, type, localName, dynamic }, {\n            name: \"string\", type: \"string\", localName: \"string\", dynamic: \"boolean\"\n        });\n    }\n    _throwError(message, value) {\n        assertArgument(false, message, this.localName, value);\n    }\n}\n/**\n *  @_ignore\n */\nexport class Writer {\n    // An array of WordSize lengthed objects to concatenation\n    #data;\n    #dataLength;\n    constructor() {\n        this.#data = [];\n        this.#dataLength = 0;\n    }\n    get data() {\n        return concat(this.#data);\n    }\n    get length() { return this.#dataLength; }\n    #writeData(data) {\n        this.#data.push(data);\n        this.#dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this.#writeData(getBytesCopy(writer.data));\n    }\n    // Arrayish item; pad on the right to *nearest* WordSize\n    writeBytes(value) {\n        let bytes = getBytesCopy(value);\n        const paddingOffset = bytes.length % WordSize;\n        if (paddingOffset) {\n            bytes = getBytesCopy(concat([bytes, Padding.slice(paddingOffset)]));\n        }\n        return this.#writeData(bytes);\n    }\n    // Numeric item; pad on the left *to* WordSize\n    writeValue(value) {\n        return this.#writeData(getValue(value));\n    }\n    // Inserts a numeric place-holder, returning a callback that can\n    // be used to asjust the value later\n    writeUpdatableValue() {\n        const offset = this.#data.length;\n        this.#data.push(Padding);\n        this.#dataLength += WordSize;\n        return (value) => {\n            this.#data[offset] = getValue(value);\n        };\n    }\n}\n/**\n *  @_ignore\n */\nexport class Reader {\n    // Allows incomplete unpadded data to be read; otherwise an error\n    // is raised if attempting to overrun the buffer. This is required\n    // to deal with an old Solidity bug, in which event data for\n    // external (not public thoguh) was tightly packed.\n    allowLoose;\n    #data;\n    #offset;\n    #bytesRead;\n    #parent;\n    #maxInflation;\n    constructor(data, allowLoose, maxInflation) {\n        defineProperties(this, { allowLoose: !!allowLoose });\n        this.#data = getBytesCopy(data);\n        this.#bytesRead = 0;\n        this.#parent = null;\n        this.#maxInflation = (maxInflation != null) ? maxInflation : 1024;\n        this.#offset = 0;\n    }\n    get data() { return hexlify(this.#data); }\n    get dataLength() { return this.#data.length; }\n    get consumed() { return this.#offset; }\n    get bytes() { return new Uint8Array(this.#data); }\n    #incrementBytesRead(count) {\n        if (this.#parent) {\n            return this.#parent.#incrementBytesRead(count);\n        }\n        this.#bytesRead += count;\n        // Check for excessive inflation (see: #4537)\n        assert(this.#maxInflation < 1 || this.#bytesRead <= this.#maxInflation * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\\/github.com/ethers-io/ethers.js/issues/4537 )`, \"BUFFER_OVERRUN\", {\n            buffer: getBytesCopy(this.#data), offset: this.#offset,\n            length: count, info: {\n                bytesRead: this.#bytesRead,\n                dataLength: this.dataLength\n            }\n        });\n    }\n    #peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / WordSize) * WordSize;\n        if (this.#offset + alignedLength > this.#data.length) {\n            if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {\n                alignedLength = length;\n            }\n            else {\n                assert(false, \"data out-of-bounds\", \"BUFFER_OVERRUN\", {\n                    buffer: getBytesCopy(this.#data),\n                    length: this.#data.length,\n                    offset: this.#offset + alignedLength\n                });\n            }\n        }\n        return this.#data.slice(this.#offset, this.#offset + alignedLength);\n    }\n    // Create a sub-reader with the same underlying data, but offset\n    subReader(offset) {\n        const reader = new Reader(this.#data.slice(this.#offset + offset), this.allowLoose, this.#maxInflation);\n        reader.#parent = this;\n        return reader;\n    }\n    // Read bytes\n    readBytes(length, loose) {\n        let bytes = this.#peekBytes(0, length, !!loose);\n        this.#incrementBytesRead(length);\n        this.#offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    // Read a numeric values\n    readValue() {\n        return toBigInt(this.readBytes(WordSize));\n    }\n    readIndex() {\n        return toNumber(this.readBytes(WordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map","function number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexport { number, bool, bytes, hash, exists, output };\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n//# sourceMappingURL=_assert.js.map","const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nexport { fromBig, split, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add, add3L, add3H, add4L, add4H, add5H, add5L, };\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n//# sourceMappingURL=_u64.js.map","/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nexport const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nexport class Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nexport function checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexport function wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32) {\n    if (crypto && typeof crypto.getRandomValues === 'function') {\n        return crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map","import { bytes, exists, number, output } from './_assert.js';\nimport { rotlBH, rotlBL, rotlSH, rotlSL, split } from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts, } from './utils.js';\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nexport class Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = u32(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        exists(this);\n        const { blockLen, state } = this;\n        data = toBytes(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        exists(this, false);\n        bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\nexport const sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nexport const sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nexport const sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nexport const keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nexport const keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nexport const keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nexport const shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nexport const shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map","/**\n *  Cryptographic hashing functions\n *\n *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]\n */\nimport { keccak_256 } from \"@noble/hashes/sha3\";\nimport { getBytes, hexlify } from \"../utils/index.js\";\nlet locked = false;\nconst _keccak256 = function (data) {\n    return keccak_256(data);\n};\nlet __keccak256 = _keccak256;\n/**\n *  Compute the cryptographic KECCAK256 hash of %%data%%.\n *\n *  The %%data%% **must** be a data representation, to compute the\n *  hash of UTF-8 data use the [[id]] function.\n *\n *  @returns DataHexstring\n *  @example:\n *    keccak256(\"0x\")\n *    //_result:\n *\n *    keccak256(\"0x1337\")\n *    //_result:\n *\n *    keccak256(new Uint8Array([ 0x13, 0x37 ]))\n *    //_result:\n *\n *    // Strings are assumed to be DataHexString, otherwise it will\n *    // throw. To hash UTF-8 data, see the note above.\n *    keccak256(\"Hello World\")\n *    //_error:\n */\nexport function keccak256(_data) {\n    const data = getBytes(_data, \"data\");\n    return hexlify(__keccak256(data));\n}\nkeccak256._ = _keccak256;\nkeccak256.lock = function () { locked = true; };\nkeccak256.register = function (func) {\n    if (locked) {\n        throw new TypeError(\"keccak256 is locked\");\n    }\n    __keccak256 = func;\n};\nObject.freeze(keccak256);\n//# sourceMappingURL=keccak.js.map","/**\n *  A constant for the zero address.\n *\n *  (**i.e.** ``\"0x0000000000000000000000000000000000000000\"``)\n */\nexport const ZeroAddress = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map","import { keccak256 } from \"../crypto/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\nconst BN_0 = BigInt(0);\nconst BN_36 = BigInt(36);\nfunction getChecksumAddress(address) {\n    //    if (!isHexString(address, 20)) {\n    //        logger.throwArgumentError(\"invalid address\", \"address\", address);\n    //    }\n    address = address.toLowerCase();\n    const chars = address.substring(2).split(\"\");\n    const expanded = new Uint8Array(40);\n    for (let i = 0; i < 40; i++) {\n        expanded[i] = chars[i].charCodeAt(0);\n    }\n    const hashed = getBytes(keccak256(expanded));\n    for (let i = 0; i < 40; i += 2) {\n        if ((hashed[i >> 1] >> 4) >= 8) {\n            chars[i] = chars[i].toUpperCase();\n        }\n        if ((hashed[i >> 1] & 0x0f) >= 8) {\n            chars[i + 1] = chars[i + 1].toUpperCase();\n        }\n    }\n    return \"0x\" + chars.join(\"\");\n}\n// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n// Create lookup table\nconst ibanLookup = {};\nfor (let i = 0; i < 10; i++) {\n    ibanLookup[String(i)] = String(i);\n}\nfor (let i = 0; i < 26; i++) {\n    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n}\n// How many decimal digits can we process? (for 64-bit float, this is 15)\n// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));\nconst safeDigits = 15;\nfunction ibanChecksum(address) {\n    address = address.toUpperCase();\n    address = address.substring(4) + address.substring(0, 2) + \"00\";\n    let expanded = address.split(\"\").map((c) => { return ibanLookup[c]; }).join(\"\");\n    // Javascript can handle integers safely up to 15 (decimal) digits\n    while (expanded.length >= safeDigits) {\n        let block = expanded.substring(0, safeDigits);\n        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n    }\n    let checksum = String(98 - (parseInt(expanded, 10) % 97));\n    while (checksum.length < 2) {\n        checksum = \"0\" + checksum;\n    }\n    return checksum;\n}\n;\nconst Base36 = (function () {\n    ;\n    const result = {};\n    for (let i = 0; i < 36; i++) {\n        const key = \"0123456789abcdefghijklmnopqrstuvwxyz\"[i];\n        result[key] = BigInt(i);\n    }\n    return result;\n})();\nfunction fromBase36(value) {\n    value = value.toLowerCase();\n    let result = BN_0;\n    for (let i = 0; i < value.length; i++) {\n        result = result * BN_36 + Base36[value[i]];\n    }\n    return result;\n}\n/**\n *  Returns a normalized and checksumed address for %%address%%.\n *  This accepts non-checksum addresses, checksum addresses and\n *  [[getIcapAddress]] formats.\n *\n *  The checksum in Ethereum uses the capitalization (upper-case\n *  vs lower-case) of the characters within an address to encode\n *  its checksum, which offers, on average, a checksum of 15-bits.\n *\n *  If %%address%% contains both upper-case and lower-case, it is\n *  assumed to already be a checksum address and its checksum is\n *  validated, and if the address fails its expected checksum an\n *  error is thrown.\n *\n *  If you wish the checksum of %%address%% to be ignore, it should\n *  be converted to lower-case (i.e. ``.toLowercase()``) before\n *  being passed in. This should be a very rare situation though,\n *  that you wish to bypass the safegaurds in place to protect\n *  against an address that has been incorrectly copied from another\n *  source.\n *\n *  @example:\n *    // Adds the checksum (via upper-casing specific letters)\n *    getAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\")\n *    //_result:\n *\n *    // Converts ICAP address and adds checksum\n *    getAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if an address contains mixed case,\n *    // but the checksum fails\n *    getAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_error:\n */\nexport function getAddress(address) {\n    assertArgument(typeof (address) === \"string\", \"invalid address\", \"address\", address);\n    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n        // Missing the 0x prefix\n        if (!address.startsWith(\"0x\")) {\n            address = \"0x\" + address;\n        }\n        const result = getChecksumAddress(address);\n        // It is a checksummed address with a bad checksum\n        assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, \"bad address checksum\", \"address\", address);\n        return result;\n    }\n    // Maybe ICAP? (we only support direct mode)\n    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n        // It is an ICAP address with a bad checksum\n        assertArgument(address.substring(2, 4) === ibanChecksum(address), \"bad icap checksum\", \"address\", address);\n        let result = fromBase36(address.substring(4)).toString(16);\n        while (result.length < 40) {\n            result = \"0\" + result;\n        }\n        return getChecksumAddress(\"0x\" + result);\n    }\n    assertArgument(false, \"invalid address\", \"address\", address);\n}\n/**\n *  The [ICAP Address format](link-icap) format is an early checksum\n *  format which attempts to be compatible with the banking\n *  industry [IBAN format](link-wiki-iban) for bank accounts.\n *\n *  It is no longer common or a recommended format.\n *\n *  @example:\n *    getIcapAddress(\"0x8ba1f109551bd432803012645ac136ddd64dba72\");\n *    //_result:\n *\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\");\n *    //_result:\n *\n *    // Throws an error if the ICAP checksum is wrong\n *    getIcapAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37\");\n *    //_error:\n */\nexport function getIcapAddress(address) {\n    //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();\n    let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();\n    while (base36.length < 30) {\n        base36 = \"0\" + base36;\n    }\n    return \"XE\" + ibanChecksum(\"XE00\" + base36) + base36;\n}\n//# sourceMappingURL=address.js.map","import { assert, assertArgument } from \"../utils/index.js\";\nimport { getAddress } from \"./address.js\";\n/**\n *  Returns true if %%value%% is an object which implements the\n *  [[Addressable]] interface.\n *\n *  @example:\n *    // Wallets and AbstractSigner sub-classes\n *    isAddressable(Wallet.createRandom())\n *    //_result:\n *\n *    // Contracts\n *    contract = new Contract(\"dai.tokens.ethers.eth\", [ ], provider)\n *    isAddressable(contract)\n *    //_result:\n */\nexport function isAddressable(value) {\n    return (value && typeof (value.getAddress) === \"function\");\n}\n/**\n *  Returns true if %%value%% is a valid address.\n *\n *  @example:\n *    // Valid address\n *    isAddress(\"0x8ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Valid ICAP address\n *    isAddress(\"XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36\")\n *    //_result:\n *\n *    // Invalid checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBa72\")\n *    //_result:\n *\n *    // Invalid ICAP checksum\n *    isAddress(\"0x8Ba1f109551bD432803012645Ac136ddd64DBA72\")\n *    //_result:\n *\n *    // Not an address (an ENS name requires a provided and an\n *    // asynchronous API to access)\n *    isAddress(\"ricmoo.eth\")\n *    //_result:\n */\nexport function isAddress(value) {\n    try {\n        getAddress(value);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nasync function checkAddress(target, promise) {\n    const result = await promise;\n    if (result == null || result === \"0x0000000000000000000000000000000000000000\") {\n        assert(typeof (target) !== \"string\", \"unconfigured name\", \"UNCONFIGURED_NAME\", { value: target });\n        assertArgument(false, \"invalid AddressLike value; did not resolve to a value address\", \"target\", target);\n    }\n    return getAddress(result);\n}\n/**\n *  Resolves to an address for the %%target%%, which may be any\n *  supported address type, an [[Addressable]] or a Promise which\n *  resolves to an address.\n *\n *  If an ENS name is provided, but that name has not been correctly\n *  configured a [[UnconfiguredNameError]] is thrown.\n *\n *  @example:\n *    addr = \"0x6B175474E89094C44Da98b954EedeAC495271d0F\"\n *\n *    // Addresses are return synchronously\n *    resolveAddress(addr, provider)\n *    //_result:\n *\n *    // Address promises are resolved asynchronously\n *    resolveAddress(Promise.resolve(addr))\n *    //_result:\n *\n *    // ENS names are resolved asynchronously\n *    resolveAddress(\"dai.tokens.ethers.eth\", provider)\n *    //_result:\n *\n *    // Addressable objects are resolved asynchronously\n *    contract = new Contract(addr, [ ])\n *    resolveAddress(contract, provider)\n *    //_result:\n *\n *    // Unconfigured ENS names reject\n *    resolveAddress(\"nothing-here.ricmoo.eth\", provider)\n *    //_error:\n *\n *    // ENS names require a NameResolver object passed in\n *    // (notice the provider was omitted)\n *    resolveAddress(\"nothing-here.ricmoo.eth\")\n *    //_error:\n */\nexport function resolveAddress(target, resolver) {\n    if (typeof (target) === \"string\") {\n        if (target.match(/^0x[0-9a-f]{40}$/i)) {\n            return getAddress(target);\n        }\n        assert(resolver != null, \"ENS resolution requires a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"resolveName\" });\n        return checkAddress(target, resolver.resolveName(target));\n    }\n    else if (isAddressable(target)) {\n        return checkAddress(target, target.getAddress());\n    }\n    else if (target && typeof (target.then) === \"function\") {\n        return checkAddress(target, target);\n    }\n    assertArgument(false, \"unsupported addressable value\", \"target\", target);\n}\n//# sourceMappingURL=checks.js.map","/**\n *  A Typed object allows a value to have its type explicitly\n *  specified.\n *\n *  For example, in Solidity, the value ``45`` could represent a\n *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent\n *  a ``bytes2`` or ``bytes``.\n *\n *  Since JavaScript has no meaningful way to explicitly inform any\n *  APIs which what the type is, this allows transparent interoperation\n *  with Soldity.\n *\n *  @_subsection: api/abi:Typed Values\n */\nimport { assertPrivate, defineProperties } from \"../utils/index.js\";\nconst _gaurd = {};\nfunction n(value, width) {\n    let signed = false;\n    if (width < 0) {\n        signed = true;\n        width *= -1;\n    }\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `${signed ? \"\" : \"u\"}int${width}`, value, { signed, width });\n}\nfunction b(value, size) {\n    // @TODO: Check range is valid for value\n    return new Typed(_gaurd, `bytes${(size) ? size : \"\"}`, value, { size });\n}\nconst _typedSymbol = Symbol.for(\"_ethers_typed\");\n/**\n *  The **Typed** class to wrap values providing explicit type information.\n */\nexport class Typed {\n    /**\n     *  The type, as a Solidity-compatible type.\n     */\n    type;\n    /**\n     *  The actual value.\n     */\n    value;\n    #options;\n    /**\n     *  @_ignore:\n     */\n    _typedSymbol;\n    /**\n     *  @_ignore:\n     */\n    constructor(gaurd, type, value, options) {\n        if (options == null) {\n            options = null;\n        }\n        assertPrivate(_gaurd, gaurd, \"Typed\");\n        defineProperties(this, { _typedSymbol, type, value });\n        this.#options = options;\n        // Check the value is valid\n        this.format();\n    }\n    /**\n     *  Format the type as a Human-Readable type.\n     */\n    format() {\n        if (this.type === \"array\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"dynamicArray\") {\n            throw new Error(\"\");\n        }\n        else if (this.type === \"tuple\") {\n            return `tuple(${this.value.map((v) => v.format()).join(\",\")})`;\n        }\n        return this.type;\n    }\n    /**\n     *  The default value returned by this type.\n     */\n    defaultValue() {\n        return 0;\n    }\n    /**\n     *  The minimum value for numeric types.\n     */\n    minValue() {\n        return 0;\n    }\n    /**\n     *  The maximum value for numeric types.\n     */\n    maxValue() {\n        return 0;\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].\n     */\n    isBigInt() {\n        return !!(this.type.match(/^u?int[0-9]+$/));\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].\n     */\n    isData() {\n        return this.type.startsWith(\"bytes\");\n    }\n    /**\n     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].\n     */\n    isString() {\n        return (this.type === \"string\");\n    }\n    /**\n     *  Returns the tuple name, if this is a tuple. Throws otherwise.\n     */\n    get tupleName() {\n        if (this.type !== \"tuple\") {\n            throw TypeError(\"not a tuple\");\n        }\n        return this.#options;\n    }\n    // Returns the length of this type as an array\n    // - `null` indicates the length is unforced, it could be dynamic\n    // - `-1` indicates the length is dynamic\n    // - any other value indicates it is a static array and is its length\n    /**\n     *  Returns the length of the array type or ``-1`` if it is dynamic.\n     *\n     *  Throws if the type is not an array.\n     */\n    get arrayLength() {\n        if (this.type !== \"array\") {\n            throw TypeError(\"not an array\");\n        }\n        if (this.#options === true) {\n            return -1;\n        }\n        if (this.#options === false) {\n            return (this.value).length;\n        }\n        return null;\n    }\n    /**\n     *  Returns a new **Typed** of %%type%% with the %%value%%.\n     */\n    static from(type, value) {\n        return new Typed(_gaurd, type, value);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static uint8(v) { return n(v, 8); }\n    /**\n     *  Return a new ``uint16`` type for %%v%%.\n     */\n    static uint16(v) { return n(v, 16); }\n    /**\n     *  Return a new ``uint24`` type for %%v%%.\n     */\n    static uint24(v) { return n(v, 24); }\n    /**\n     *  Return a new ``uint32`` type for %%v%%.\n     */\n    static uint32(v) { return n(v, 32); }\n    /**\n     *  Return a new ``uint40`` type for %%v%%.\n     */\n    static uint40(v) { return n(v, 40); }\n    /**\n     *  Return a new ``uint48`` type for %%v%%.\n     */\n    static uint48(v) { return n(v, 48); }\n    /**\n     *  Return a new ``uint56`` type for %%v%%.\n     */\n    static uint56(v) { return n(v, 56); }\n    /**\n     *  Return a new ``uint64`` type for %%v%%.\n     */\n    static uint64(v) { return n(v, 64); }\n    /**\n     *  Return a new ``uint72`` type for %%v%%.\n     */\n    static uint72(v) { return n(v, 72); }\n    /**\n     *  Return a new ``uint80`` type for %%v%%.\n     */\n    static uint80(v) { return n(v, 80); }\n    /**\n     *  Return a new ``uint88`` type for %%v%%.\n     */\n    static uint88(v) { return n(v, 88); }\n    /**\n     *  Return a new ``uint96`` type for %%v%%.\n     */\n    static uint96(v) { return n(v, 96); }\n    /**\n     *  Return a new ``uint104`` type for %%v%%.\n     */\n    static uint104(v) { return n(v, 104); }\n    /**\n     *  Return a new ``uint112`` type for %%v%%.\n     */\n    static uint112(v) { return n(v, 112); }\n    /**\n     *  Return a new ``uint120`` type for %%v%%.\n     */\n    static uint120(v) { return n(v, 120); }\n    /**\n     *  Return a new ``uint128`` type for %%v%%.\n     */\n    static uint128(v) { return n(v, 128); }\n    /**\n     *  Return a new ``uint136`` type for %%v%%.\n     */\n    static uint136(v) { return n(v, 136); }\n    /**\n     *  Return a new ``uint144`` type for %%v%%.\n     */\n    static uint144(v) { return n(v, 144); }\n    /**\n     *  Return a new ``uint152`` type for %%v%%.\n     */\n    static uint152(v) { return n(v, 152); }\n    /**\n     *  Return a new ``uint160`` type for %%v%%.\n     */\n    static uint160(v) { return n(v, 160); }\n    /**\n     *  Return a new ``uint168`` type for %%v%%.\n     */\n    static uint168(v) { return n(v, 168); }\n    /**\n     *  Return a new ``uint176`` type for %%v%%.\n     */\n    static uint176(v) { return n(v, 176); }\n    /**\n     *  Return a new ``uint184`` type for %%v%%.\n     */\n    static uint184(v) { return n(v, 184); }\n    /**\n     *  Return a new ``uint192`` type for %%v%%.\n     */\n    static uint192(v) { return n(v, 192); }\n    /**\n     *  Return a new ``uint200`` type for %%v%%.\n     */\n    static uint200(v) { return n(v, 200); }\n    /**\n     *  Return a new ``uint208`` type for %%v%%.\n     */\n    static uint208(v) { return n(v, 208); }\n    /**\n     *  Return a new ``uint216`` type for %%v%%.\n     */\n    static uint216(v) { return n(v, 216); }\n    /**\n     *  Return a new ``uint224`` type for %%v%%.\n     */\n    static uint224(v) { return n(v, 224); }\n    /**\n     *  Return a new ``uint232`` type for %%v%%.\n     */\n    static uint232(v) { return n(v, 232); }\n    /**\n     *  Return a new ``uint240`` type for %%v%%.\n     */\n    static uint240(v) { return n(v, 240); }\n    /**\n     *  Return a new ``uint248`` type for %%v%%.\n     */\n    static uint248(v) { return n(v, 248); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint256(v) { return n(v, 256); }\n    /**\n     *  Return a new ``uint256`` type for %%v%%.\n     */\n    static uint(v) { return n(v, 256); }\n    /**\n     *  Return a new ``int8`` type for %%v%%.\n     */\n    static int8(v) { return n(v, -8); }\n    /**\n     *  Return a new ``int16`` type for %%v%%.\n     */\n    static int16(v) { return n(v, -16); }\n    /**\n     *  Return a new ``int24`` type for %%v%%.\n     */\n    static int24(v) { return n(v, -24); }\n    /**\n     *  Return a new ``int32`` type for %%v%%.\n     */\n    static int32(v) { return n(v, -32); }\n    /**\n     *  Return a new ``int40`` type for %%v%%.\n     */\n    static int40(v) { return n(v, -40); }\n    /**\n     *  Return a new ``int48`` type for %%v%%.\n     */\n    static int48(v) { return n(v, -48); }\n    /**\n     *  Return a new ``int56`` type for %%v%%.\n     */\n    static int56(v) { return n(v, -56); }\n    /**\n     *  Return a new ``int64`` type for %%v%%.\n     */\n    static int64(v) { return n(v, -64); }\n    /**\n     *  Return a new ``int72`` type for %%v%%.\n     */\n    static int72(v) { return n(v, -72); }\n    /**\n     *  Return a new ``int80`` type for %%v%%.\n     */\n    static int80(v) { return n(v, -80); }\n    /**\n     *  Return a new ``int88`` type for %%v%%.\n     */\n    static int88(v) { return n(v, -88); }\n    /**\n     *  Return a new ``int96`` type for %%v%%.\n     */\n    static int96(v) { return n(v, -96); }\n    /**\n     *  Return a new ``int104`` type for %%v%%.\n     */\n    static int104(v) { return n(v, -104); }\n    /**\n     *  Return a new ``int112`` type for %%v%%.\n     */\n    static int112(v) { return n(v, -112); }\n    /**\n     *  Return a new ``int120`` type for %%v%%.\n     */\n    static int120(v) { return n(v, -120); }\n    /**\n     *  Return a new ``int128`` type for %%v%%.\n     */\n    static int128(v) { return n(v, -128); }\n    /**\n     *  Return a new ``int136`` type for %%v%%.\n     */\n    static int136(v) { return n(v, -136); }\n    /**\n     *  Return a new ``int144`` type for %%v%%.\n     */\n    static int144(v) { return n(v, -144); }\n    /**\n     *  Return a new ``int52`` type for %%v%%.\n     */\n    static int152(v) { return n(v, -152); }\n    /**\n     *  Return a new ``int160`` type for %%v%%.\n     */\n    static int160(v) { return n(v, -160); }\n    /**\n     *  Return a new ``int168`` type for %%v%%.\n     */\n    static int168(v) { return n(v, -168); }\n    /**\n     *  Return a new ``int176`` type for %%v%%.\n     */\n    static int176(v) { return n(v, -176); }\n    /**\n     *  Return a new ``int184`` type for %%v%%.\n     */\n    static int184(v) { return n(v, -184); }\n    /**\n     *  Return a new ``int92`` type for %%v%%.\n     */\n    static int192(v) { return n(v, -192); }\n    /**\n     *  Return a new ``int200`` type for %%v%%.\n     */\n    static int200(v) { return n(v, -200); }\n    /**\n     *  Return a new ``int208`` type for %%v%%.\n     */\n    static int208(v) { return n(v, -208); }\n    /**\n     *  Return a new ``int216`` type for %%v%%.\n     */\n    static int216(v) { return n(v, -216); }\n    /**\n     *  Return a new ``int224`` type for %%v%%.\n     */\n    static int224(v) { return n(v, -224); }\n    /**\n     *  Return a new ``int232`` type for %%v%%.\n     */\n    static int232(v) { return n(v, -232); }\n    /**\n     *  Return a new ``int240`` type for %%v%%.\n     */\n    static int240(v) { return n(v, -240); }\n    /**\n     *  Return a new ``int248`` type for %%v%%.\n     */\n    static int248(v) { return n(v, -248); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int256(v) { return n(v, -256); }\n    /**\n     *  Return a new ``int256`` type for %%v%%.\n     */\n    static int(v) { return n(v, -256); }\n    /**\n     *  Return a new ``bytes1`` type for %%v%%.\n     */\n    static bytes1(v) { return b(v, 1); }\n    /**\n     *  Return a new ``bytes2`` type for %%v%%.\n     */\n    static bytes2(v) { return b(v, 2); }\n    /**\n     *  Return a new ``bytes3`` type for %%v%%.\n     */\n    static bytes3(v) { return b(v, 3); }\n    /**\n     *  Return a new ``bytes4`` type for %%v%%.\n     */\n    static bytes4(v) { return b(v, 4); }\n    /**\n     *  Return a new ``bytes5`` type for %%v%%.\n     */\n    static bytes5(v) { return b(v, 5); }\n    /**\n     *  Return a new ``bytes6`` type for %%v%%.\n     */\n    static bytes6(v) { return b(v, 6); }\n    /**\n     *  Return a new ``bytes7`` type for %%v%%.\n     */\n    static bytes7(v) { return b(v, 7); }\n    /**\n     *  Return a new ``bytes8`` type for %%v%%.\n     */\n    static bytes8(v) { return b(v, 8); }\n    /**\n     *  Return a new ``bytes9`` type for %%v%%.\n     */\n    static bytes9(v) { return b(v, 9); }\n    /**\n     *  Return a new ``bytes10`` type for %%v%%.\n     */\n    static bytes10(v) { return b(v, 10); }\n    /**\n     *  Return a new ``bytes11`` type for %%v%%.\n     */\n    static bytes11(v) { return b(v, 11); }\n    /**\n     *  Return a new ``bytes12`` type for %%v%%.\n     */\n    static bytes12(v) { return b(v, 12); }\n    /**\n     *  Return a new ``bytes13`` type for %%v%%.\n     */\n    static bytes13(v) { return b(v, 13); }\n    /**\n     *  Return a new ``bytes14`` type for %%v%%.\n     */\n    static bytes14(v) { return b(v, 14); }\n    /**\n     *  Return a new ``bytes15`` type for %%v%%.\n     */\n    static bytes15(v) { return b(v, 15); }\n    /**\n     *  Return a new ``bytes16`` type for %%v%%.\n     */\n    static bytes16(v) { return b(v, 16); }\n    /**\n     *  Return a new ``bytes17`` type for %%v%%.\n     */\n    static bytes17(v) { return b(v, 17); }\n    /**\n     *  Return a new ``bytes18`` type for %%v%%.\n     */\n    static bytes18(v) { return b(v, 18); }\n    /**\n     *  Return a new ``bytes19`` type for %%v%%.\n     */\n    static bytes19(v) { return b(v, 19); }\n    /**\n     *  Return a new ``bytes20`` type for %%v%%.\n     */\n    static bytes20(v) { return b(v, 20); }\n    /**\n     *  Return a new ``bytes21`` type for %%v%%.\n     */\n    static bytes21(v) { return b(v, 21); }\n    /**\n     *  Return a new ``bytes22`` type for %%v%%.\n     */\n    static bytes22(v) { return b(v, 22); }\n    /**\n     *  Return a new ``bytes23`` type for %%v%%.\n     */\n    static bytes23(v) { return b(v, 23); }\n    /**\n     *  Return a new ``bytes24`` type for %%v%%.\n     */\n    static bytes24(v) { return b(v, 24); }\n    /**\n     *  Return a new ``bytes25`` type for %%v%%.\n     */\n    static bytes25(v) { return b(v, 25); }\n    /**\n     *  Return a new ``bytes26`` type for %%v%%.\n     */\n    static bytes26(v) { return b(v, 26); }\n    /**\n     *  Return a new ``bytes27`` type for %%v%%.\n     */\n    static bytes27(v) { return b(v, 27); }\n    /**\n     *  Return a new ``bytes28`` type for %%v%%.\n     */\n    static bytes28(v) { return b(v, 28); }\n    /**\n     *  Return a new ``bytes29`` type for %%v%%.\n     */\n    static bytes29(v) { return b(v, 29); }\n    /**\n     *  Return a new ``bytes30`` type for %%v%%.\n     */\n    static bytes30(v) { return b(v, 30); }\n    /**\n     *  Return a new ``bytes31`` type for %%v%%.\n     */\n    static bytes31(v) { return b(v, 31); }\n    /**\n     *  Return a new ``bytes32`` type for %%v%%.\n     */\n    static bytes32(v) { return b(v, 32); }\n    /**\n     *  Return a new ``address`` type for %%v%%.\n     */\n    static address(v) { return new Typed(_gaurd, \"address\", v); }\n    /**\n     *  Return a new ``bool`` type for %%v%%.\n     */\n    static bool(v) { return new Typed(_gaurd, \"bool\", !!v); }\n    /**\n     *  Return a new ``bytes`` type for %%v%%.\n     */\n    static bytes(v) { return new Typed(_gaurd, \"bytes\", v); }\n    /**\n     *  Return a new ``string`` type for %%v%%.\n     */\n    static string(v) { return new Typed(_gaurd, \"string\", v); }\n    /**\n     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.\n     */\n    static array(v, dynamic) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"array\", v, dynamic);\n    }\n    /**\n     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.\n     */\n    static tuple(v, name) {\n        throw new Error(\"not implemented yet\");\n        return new Typed(_gaurd, \"tuple\", v, name);\n    }\n    /**\n     *  Return a new ``uint8`` type for %%v%%.\n     */\n    static overrides(v) {\n        return new Typed(_gaurd, \"overrides\", Object.assign({}, v));\n    }\n    /**\n     *  Returns true only if %%value%% is a [[Typed]] instance.\n     */\n    static isTyped(value) {\n        return (value\n            && typeof (value) === \"object\"\n            && \"_typedSymbol\" in value\n            && value._typedSymbol === _typedSymbol);\n    }\n    /**\n     *  If the value is a [[Typed]] instance, validates the underlying value\n     *  and returns it, otherwise returns value directly.\n     *\n     *  This is useful for functions that with to accept either a [[Typed]]\n     *  object or values.\n     */\n    static dereference(value, type) {\n        if (Typed.isTyped(value)) {\n            if (value.type !== type) {\n                throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);\n            }\n            return value.value;\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=typed.js.map","import { getAddress } from \"../../address/index.js\";\nimport { toBeHex } from \"../../utils/maths.js\";\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n/**\n *  @_ignore\n */\nexport class AddressCoder extends Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, _value) {\n        let value = Typed.dereference(_value, \"string\");\n        try {\n            value = getAddress(value);\n        }\n        catch (error) {\n            return this._throwError(error.message, _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return getAddress(toBeHex(reader.readValue(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map","import { Coder } from \"./abstract-coder.js\";\n/**\n *  Clones the functionality of an existing Coder, but without a localName\n *\n *  @_ignore\n */\nexport class AnonymousCoder extends Coder {\n    coder;\n    constructor(coder) {\n        super(coder.name, coder.type, \"_\", coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map","import { defineProperties, isError, assert, assertArgument, assertArgumentCount } from \"../../utils/index.js\";\nimport { Typed } from \"../typed.js\";\nimport { Coder, Result, WordSize, Writer } from \"./abstract-coder.js\";\nimport { AnonymousCoder } from \"./anonymous.js\";\n/**\n *  @_ignore\n */\nexport function pack(writer, coders, values) {\n    let arrayValues = [];\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            assert(name, \"cannot encode object for signature with missing names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            assert(!unique[name], \"cannot encode object for signature with duplicate names\", \"INVALID_ARGUMENT\", { argument: \"values\", info: { coder }, value: values });\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        assertArgument(false, \"invalid tuple value\", \"tuple\", values);\n    }\n    assertArgument(coders.length === arrayValues.length, \"types/value length mismatch\", \"tuple\", values);\n    let staticWriter = new Writer();\n    let dynamicWriter = new Writer();\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\n/**\n *  @_ignore\n */\nexport function unpack(reader, coders) {\n    let values = [];\n    let keys = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readIndex();\n            let offsetReader = baseReader.subReader(offset);\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (isError(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (isError(error, \"BUFFER_OVERRUN\")) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value == undefined) {\n            throw new Error(\"investigate\");\n        }\n        values.push(value);\n        keys.push(coder.localName || null);\n    });\n    return Result.fromItems(values, keys);\n}\n/**\n *  @_ignore\n */\nexport class ArrayCoder extends Coder {\n    coder;\n    length;\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        defineProperties(this, { coder, length });\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, _value) {\n        const value = Typed.dereference(_value, \"array\");\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        assertArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readIndex();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            assert(count * WordSize <= reader.dataLength, \"insufficient data length\", \"BUFFER_OVERRUN\", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new AnonymousCoder(this.coder));\n        }\n        return unpack(reader, coders);\n    }\n}\n//# sourceMappingURL=array.js.map","import { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n/**\n *  @_ignore\n */\nexport class BooleanCoder extends Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, _value) {\n        const value = Typed.dereference(_value, \"bool\");\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return !!reader.readValue();\n    }\n}\n//# sourceMappingURL=boolean.js.map","import { getBytesCopy, hexlify } from \"../../utils/index.js\";\nimport { Coder } from \"./abstract-coder.js\";\n/**\n *  @_ignore\n */\nexport class DynamicBytesCoder extends Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = getBytesCopy(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readIndex(), true);\n    }\n}\n/**\n *  @_ignore\n */\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return hexlify(super.decode(reader));\n    }\n}\n//# sourceMappingURL=bytes.js.map","import { defineProperties, getBytesCopy, hexlify } from \"../../utils/index.js\";\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\n/**\n *  @_ignore\n */\nexport class FixedBytesCoder extends Coder {\n    size;\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        defineProperties(this, { size }, { size: \"number\" });\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, _value) {\n        let data = getBytesCopy(Typed.dereference(_value, this.type));\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", _value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return hexlify(reader.readBytes(this.size));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map","import { Coder } from \"./abstract-coder.js\";\nconst Empty = new Uint8Array([]);\n/**\n *  @_ignore\n */\nexport class NullCoder extends Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes(Empty);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return null;\n    }\n}\n//# sourceMappingURL=null.js.map","import { defineProperties, fromTwos, getBigInt, mask, toTwos } from \"../../utils/index.js\";\nimport { Typed } from \"../typed.js\";\nimport { Coder, WordSize } from \"./abstract-coder.js\";\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n/**\n *  @_ignore\n */\nexport class NumberCoder extends Coder {\n    size;\n    signed;\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        defineProperties(this, { size, signed }, { size: \"number\", signed: \"boolean\" });\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, _value) {\n        let value = getBigInt(Typed.dereference(_value, this.type));\n        // Check bounds are safe for encoding\n        let maxUintValue = mask(BN_MAX_UINT256, WordSize * 8);\n        if (this.signed) {\n            let bounds = mask(maxUintValue, (this.size * 8) - 1);\n            if (value > bounds || value < -(bounds + BN_1)) {\n                this._throwError(\"value out-of-bounds\", _value);\n            }\n            value = toTwos(value, 8 * WordSize);\n        }\n        else if (value < BN_0 || value > mask(maxUintValue, this.size * 8)) {\n            this._throwError(\"value out-of-bounds\", _value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        let value = mask(reader.readValue(), this.size * 8);\n        if (this.signed) {\n            value = fromTwos(value, this.size * 8);\n        }\n        return value;\n    }\n}\n//# sourceMappingURL=number.js.map","import { toUtf8Bytes, toUtf8String } from \"../../utils/utf8.js\";\nimport { Typed } from \"../typed.js\";\nimport { DynamicBytesCoder } from \"./bytes.js\";\n/**\n *  @_ignore\n */\nexport class StringCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, _value) {\n        return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, \"string\")));\n    }\n    decode(reader) {\n        return toUtf8String(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map","import { defineProperties } from \"../../utils/properties.js\";\nimport { Typed } from \"../typed.js\";\nimport { Coder } from \"./abstract-coder.js\";\nimport { pack, unpack } from \"./array.js\";\n/**\n *  @_ignore\n */\nexport class TupleCoder extends Coder {\n    coders;\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        defineProperties(this, { coders: Object.freeze(coders.slice()) });\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, _value) {\n        const value = Typed.dereference(_value, \"tuple\");\n        return pack(writer, this.coders, value);\n    }\n    decode(reader) {\n        return unpack(reader, this.coders);\n    }\n}\n//# sourceMappingURL=tuple.js.map","import { keccak256 } from \"../crypto/index.js\";\nimport { toUtf8Bytes } from \"../utils/index.js\";\n/**\n *  A simple hashing function which operates on UTF-8 strings to\n *  compute an 32-byte identifier.\n *\n *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes\n *  the [[keccak256]].\n *\n *  @example:\n *    id(\"hello world\")\n *    //_result:\n */\nexport function id(value) {\n    return keccak256(toUtf8Bytes(value));\n}\n//# sourceMappingURL=id.js.map","import { getAddress } from \"../address/index.js\";\nimport { assertArgument, isHexString } from \"../utils/index.js\";\nfunction accessSetify(addr, storageKeys) {\n    return {\n        address: getAddress(addr),\n        storageKeys: storageKeys.map((storageKey, index) => {\n            assertArgument(isHexString(storageKey, 32), \"invalid slot\", `storageKeys[${index}]`, storageKey);\n            return storageKey.toLowerCase();\n        })\n    };\n}\n/**\n *  Returns a [[AccessList]] from any ethers-supported access-list structure.\n */\nexport function accessListify(value) {\n    if (Array.isArray(value)) {\n        return value.map((set, index) => {\n            if (Array.isArray(set)) {\n                assertArgument(set.length === 2, \"invalid slot set\", `value[${index}]`, set);\n                return accessSetify(set[0], set[1]);\n            }\n            assertArgument(set != null && typeof (set) === \"object\", \"invalid address-slot set\", \"value\", value);\n            return accessSetify(set.address, set.storageKeys);\n        });\n    }\n    assertArgument(value != null && typeof (value) === \"object\", \"invalid access list\", \"value\", value);\n    const result = Object.keys(value).map((addr) => {\n        const storageKeys = value[addr].reduce((accum, storageKey) => {\n            accum[storageKey] = true;\n            return accum;\n        }, {});\n        return accessSetify(addr, Object.keys(storageKeys).sort());\n    });\n    result.sort((a, b) => (a.address.localeCompare(b.address)));\n    return result;\n}\n//# sourceMappingURL=accesslist.js.map","import { getAddress } from \"../address/index.js\";\nimport { keccak256 as _keccak256, sha256 as _sha256 } from \"../crypto/index.js\";\nimport { concat, dataLength, getBytes, hexlify, toBeArray, toTwos, toUtf8Bytes, zeroPadBytes, zeroPadValue, assertArgument } from \"../utils/index.js\";\nconst regexBytes = new RegExp(\"^bytes([0-9]+)$\");\nconst regexNumber = new RegExp(\"^(u?int)([0-9]*)$\");\nconst regexArray = new RegExp(\"^(.*)\\\\[([0-9]*)\\\\]$\");\nfunction _pack(type, value, isArray) {\n    switch (type) {\n        case \"address\":\n            if (isArray) {\n                return getBytes(zeroPadValue(value, 32));\n            }\n            return getBytes(getAddress(value));\n        case \"string\":\n            return toUtf8Bytes(value);\n        case \"bytes\":\n            return getBytes(value);\n        case \"bool\":\n            value = (!!value ? \"0x01\" : \"0x00\");\n            if (isArray) {\n                return getBytes(zeroPadValue(value, 32));\n            }\n            return getBytes(value);\n    }\n    let match = type.match(regexNumber);\n    if (match) {\n        let signed = (match[1] === \"int\");\n        let size = parseInt(match[2] || \"256\");\n        assertArgument((!match[2] || match[2] === String(size)) && (size % 8 === 0) && size !== 0 && size <= 256, \"invalid number type\", \"type\", type);\n        if (isArray) {\n            size = 256;\n        }\n        if (signed) {\n            value = toTwos(value, size);\n        }\n        return getBytes(zeroPadValue(toBeArray(value), size / 8));\n    }\n    match = type.match(regexBytes);\n    if (match) {\n        const size = parseInt(match[1]);\n        assertArgument(String(size) === match[1] && size !== 0 && size <= 32, \"invalid bytes type\", \"type\", type);\n        assertArgument(dataLength(value) === size, `invalid value for ${type}`, \"value\", value);\n        if (isArray) {\n            return getBytes(zeroPadBytes(value, 32));\n        }\n        return value;\n    }\n    match = type.match(regexArray);\n    if (match && Array.isArray(value)) {\n        const baseType = match[1];\n        const count = parseInt(match[2] || String(value.length));\n        assertArgument(count === value.length, `invalid array length for ${type}`, \"value\", value);\n        const result = [];\n        value.forEach(function (value) {\n            result.push(_pack(baseType, value, true));\n        });\n        return getBytes(concat(result));\n    }\n    assertArgument(false, \"invalid type\", \"type\", type);\n}\n// @TODO: Array Enum\n/**\n *   Computes the [[link-solc-packed]] representation of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPacked([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPacked(types, values) {\n    assertArgument(types.length === values.length, \"wrong number of values; expected ${ types.length }\", \"values\", values);\n    const tight = [];\n    types.forEach(function (type, index) {\n        tight.push(_pack(type, values[index]));\n    });\n    return hexlify(concat(tight));\n}\n/**\n *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedKeccak256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPackedKeccak256(types, values) {\n    return _keccak256(solidityPacked(types, values));\n}\n/**\n *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%\n *   respectively to their %%types%%.\n *\n *   @example:\n *       addr = \"0x8ba1f109551bd432803012645ac136ddd64dba72\"\n *       solidityPackedSha256([ \"address\", \"uint\" ], [ addr, 45 ]);\n *       //_result:\n */\nexport function solidityPackedSha256(types, values) {\n    return _sha256(solidityPacked(types, values));\n}\n//# sourceMappingURL=solidity.js.map","/**\n *  A fragment is a single item from an ABI, which may represent any of:\n *\n *  - [Functions](FunctionFragment)\n *  - [Events](EventFragment)\n *  - [Constructors](ConstructorFragment)\n *  - Custom [Errors](ErrorFragment)\n *  - [Fallback or Receive](FallbackFragment) functions\n *\n *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]\n */\nimport { defineProperties, getBigInt, getNumber, assert, assertPrivate, assertArgument } from \"../utils/index.js\";\nimport { id } from \"../hash/index.js\";\n;\n// [ \"a\", \"b\" ] => { \"a\": 1, \"b\": 1 }\nfunction setify(items) {\n    const result = new Set();\n    items.forEach((k) => result.add(k));\n    return Object.freeze(result);\n}\nconst _kwVisibDeploy = \"external public payable override\";\nconst KwVisibDeploy = setify(_kwVisibDeploy.split(\" \"));\n// Visibility Keywords\nconst _kwVisib = \"constant external internal payable private public pure view override\";\nconst KwVisib = setify(_kwVisib.split(\" \"));\nconst _kwTypes = \"constructor error event fallback function receive struct\";\nconst KwTypes = setify(_kwTypes.split(\" \"));\nconst _kwModifiers = \"calldata memory storage payable indexed\";\nconst KwModifiers = setify(_kwModifiers.split(\" \"));\nconst _kwOther = \"tuple returns\";\n// All Keywords\nconst _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(\" \");\nconst Keywords = setify(_keywords.split(\" \"));\n// Single character tokens\nconst SimpleTokens = {\n    \"(\": \"OPEN_PAREN\", \")\": \"CLOSE_PAREN\",\n    \"[\": \"OPEN_BRACKET\", \"]\": \"CLOSE_BRACKET\",\n    \",\": \"COMMA\", \"@\": \"AT\"\n};\n// Parser regexes to consume the next token\nconst regexWhitespacePrefix = new RegExp(\"^(\\\\s*)\");\nconst regexNumberPrefix = new RegExp(\"^([0-9]+)\");\nconst regexIdPrefix = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)\");\n// Parser regexs to check validity\nconst regexId = new RegExp(\"^([a-zA-Z$_][a-zA-Z0-9$_]*)$\");\nconst regexType = new RegExp(\"^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$\");\nclass TokenString {\n    #offset;\n    #tokens;\n    get offset() { return this.#offset; }\n    get length() { return this.#tokens.length - this.#offset; }\n    constructor(tokens) {\n        this.#offset = 0;\n        this.#tokens = tokens.slice();\n    }\n    clone() { return new TokenString(this.#tokens); }\n    reset() { this.#offset = 0; }\n    #subTokenString(from = 0, to = 0) {\n        return new TokenString(this.#tokens.slice(from, to).map((t) => {\n            return Object.freeze(Object.assign({}, t, {\n                match: (t.match - from),\n                linkBack: (t.linkBack - from),\n                linkNext: (t.linkNext - from),\n            }));\n        }));\n    }\n    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens\n    popKeyword(allowed) {\n        const top = this.peek();\n        if (top.type !== \"KEYWORD\" || !allowed.has(top.text)) {\n            throw new Error(`expected keyword ${top.text}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns the value of the next token if it is `type`; throws if out of tokens\n    popType(type) {\n        if (this.peek().type !== type) {\n            const top = this.peek();\n            throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`);\n        }\n        return this.pop().text;\n    }\n    // Pops and returns a \"(\" TOKENS \")\"\n    popParen() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = this.#subTokenString(this.#offset + 1, top.match + 1);\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Pops and returns the items within \"(\" ITEM1 \",\" ITEM2 \",\" ... \")\"\n    popParams() {\n        const top = this.peek();\n        if (top.type !== \"OPEN_PAREN\") {\n            throw new Error(\"bad start\");\n        }\n        const result = [];\n        while (this.#offset < top.match - 1) {\n            const link = this.peek().linkNext;\n            result.push(this.#subTokenString(this.#offset + 1, link));\n            this.#offset = link;\n        }\n        this.#offset = top.match + 1;\n        return result;\n    }\n    // Returns the top Token, throwing if out of tokens\n    peek() {\n        if (this.#offset >= this.#tokens.length) {\n            throw new Error(\"out-of-bounds\");\n        }\n        return this.#tokens[this.#offset];\n    }\n    // Returns the next value, if it is a keyword in `allowed`\n    peekKeyword(allowed) {\n        const top = this.peekType(\"KEYWORD\");\n        return (top != null && allowed.has(top)) ? top : null;\n    }\n    // Returns the value of the next token if it is `type`\n    peekType(type) {\n        if (this.length === 0) {\n            return null;\n        }\n        const top = this.peek();\n        return (top.type === type) ? top.text : null;\n    }\n    // Returns the next token; throws if out of tokens\n    pop() {\n        const result = this.peek();\n        this.#offset++;\n        return result;\n    }\n    toString() {\n        const tokens = [];\n        for (let i = this.#offset; i < this.#tokens.length; i++) {\n            const token = this.#tokens[i];\n            tokens.push(`${token.type}:${token.text}`);\n        }\n        return `<TokenString ${tokens.join(\" \")}>`;\n    }\n}\nfunction lex(text) {\n    const tokens = [];\n    const throwError = (message) => {\n        const token = (offset < text.length) ? JSON.stringify(text[offset]) : \"$EOI\";\n        throw new Error(`invalid token ${token} at ${offset}: ${message}`);\n    };\n    let brackets = [];\n    let commas = [];\n    let offset = 0;\n    while (offset < text.length) {\n        // Strip off any leading whitespace\n        let cur = text.substring(offset);\n        let match = cur.match(regexWhitespacePrefix);\n        if (match) {\n            offset += match[1].length;\n            cur = text.substring(offset);\n        }\n        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: \"\", text: \"\", offset, value: -1 };\n        tokens.push(token);\n        let type = (SimpleTokens[cur[0]] || \"\");\n        if (type) {\n            token.type = type;\n            token.text = cur[0];\n            offset++;\n            if (type === \"OPEN_PAREN\") {\n                brackets.push(tokens.length - 1);\n                commas.push(tokens.length - 1);\n            }\n            else if (type == \"CLOSE_PAREN\") {\n                if (brackets.length === 0) {\n                    throwError(\"no matching open bracket\");\n                }\n                token.match = brackets.pop();\n                (tokens[token.match]).match = tokens.length - 1;\n                token.depth--;\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n            }\n            else if (type === \"COMMA\") {\n                token.linkBack = commas.pop();\n                (tokens[token.linkBack]).linkNext = tokens.length - 1;\n                commas.push(tokens.length - 1);\n            }\n            else if (type === \"OPEN_BRACKET\") {\n                token.type = \"BRACKET\";\n            }\n            else if (type === \"CLOSE_BRACKET\") {\n                // Remove the CLOSE_BRACKET\n                let suffix = tokens.pop().text;\n                if (tokens.length > 0 && tokens[tokens.length - 1].type === \"NUMBER\") {\n                    const value = tokens.pop().text;\n                    suffix = value + suffix;\n                    (tokens[tokens.length - 1]).value = getNumber(value);\n                }\n                if (tokens.length === 0 || tokens[tokens.length - 1].type !== \"BRACKET\") {\n                    throw new Error(\"missing opening bracket\");\n                }\n                (tokens[tokens.length - 1]).text += suffix;\n            }\n            continue;\n        }\n        match = cur.match(regexIdPrefix);\n        if (match) {\n            token.text = match[1];\n            offset += token.text.length;\n            if (Keywords.has(token.text)) {\n                token.type = \"KEYWORD\";\n                continue;\n            }\n            if (token.text.match(regexType)) {\n                token.type = \"TYPE\";\n                continue;\n            }\n            token.type = \"ID\";\n            continue;\n        }\n        match = cur.match(regexNumberPrefix);\n        if (match) {\n            token.text = match[1];\n            token.type = \"NUMBER\";\n            offset += token.text.length;\n            continue;\n        }\n        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);\n    }\n    return new TokenString(tokens.map((t) => Object.freeze(t)));\n}\n// Check only one of `allowed` is in `set`\nfunction allowSingle(set, allowed) {\n    let included = [];\n    for (const key in allowed.keys()) {\n        if (set.has(key)) {\n            included.push(key);\n        }\n    }\n    if (included.length > 1) {\n        throw new Error(`conflicting types: ${included.join(\", \")}`);\n    }\n}\n// Functions to process a Solidity Signature TokenString from left-to-right for...\n// ...the name with an optional type, returning the name\nfunction consumeName(type, tokens) {\n    if (tokens.peekKeyword(KwTypes)) {\n        const keyword = tokens.pop().text;\n        if (keyword !== type) {\n            throw new Error(`expected ${type}, got ${keyword}`);\n        }\n    }\n    return tokens.popType(\"ID\");\n}\n// ...all keywords matching allowed, returning the keywords\nfunction consumeKeywords(tokens, allowed) {\n    const keywords = new Set();\n    while (true) {\n        const keyword = tokens.peekType(\"KEYWORD\");\n        if (keyword == null || (allowed && !allowed.has(keyword))) {\n            break;\n        }\n        tokens.pop();\n        if (keywords.has(keyword)) {\n            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);\n        }\n        keywords.add(keyword);\n    }\n    return Object.freeze(keywords);\n}\n// ...all visibility keywords, returning the coalesced mutability\nfunction consumeMutability(tokens) {\n    let modifiers = consumeKeywords(tokens, KwVisib);\n    // Detect conflicting modifiers\n    allowSingle(modifiers, setify(\"constant payable nonpayable\".split(\" \")));\n    allowSingle(modifiers, setify(\"pure view payable nonpayable\".split(\" \")));\n    // Process mutability states\n    if (modifiers.has(\"view\")) {\n        return \"view\";\n    }\n    if (modifiers.has(\"pure\")) {\n        return \"pure\";\n    }\n    if (modifiers.has(\"payable\")) {\n        return \"payable\";\n    }\n    if (modifiers.has(\"nonpayable\")) {\n        return \"nonpayable\";\n    }\n    // Process legacy `constant` last\n    if (modifiers.has(\"constant\")) {\n        return \"view\";\n    }\n    return \"nonpayable\";\n}\n// ...a parameter list, returning the ParamType list\nfunction consumeParams(tokens, allowIndexed) {\n    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));\n}\n// ...a gas limit, returning a BigNumber or null if none\nfunction consumeGas(tokens) {\n    if (tokens.peekType(\"AT\")) {\n        tokens.pop();\n        if (tokens.peekType(\"NUMBER\")) {\n            return getBigInt(tokens.pop().text);\n        }\n        throw new Error(\"invalid gas\");\n    }\n    return null;\n}\nfunction consumeEoi(tokens) {\n    if (tokens.length) {\n        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);\n    }\n}\nconst regexArrayType = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nfunction verifyBasicType(type) {\n    const match = type.match(regexType);\n    assertArgument(match, \"invalid type\", \"type\", type);\n    if (type === \"uint\") {\n        return \"uint256\";\n    }\n    if (type === \"int\") {\n        return \"int256\";\n    }\n    if (match[2]) {\n        // bytesXX\n        const length = parseInt(match[2]);\n        assertArgument(length !== 0 && length <= 32, \"invalid bytes length\", \"type\", type);\n    }\n    else if (match[3]) {\n        // intXX or uintXX\n        const size = parseInt(match[3]);\n        assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid numeric width\", \"type\", type);\n    }\n    return type;\n}\n// Make the Fragment constructors effectively private\nconst _guard = {};\nconst internal = Symbol.for(\"_ethers_internal\");\nconst ParamTypeInternal = \"_ParamTypeInternal\";\nconst ErrorFragmentInternal = \"_ErrorInternal\";\nconst EventFragmentInternal = \"_EventInternal\";\nconst ConstructorFragmentInternal = \"_ConstructorInternal\";\nconst FallbackFragmentInternal = \"_FallbackInternal\";\nconst FunctionFragmentInternal = \"_FunctionInternal\";\nconst StructFragmentInternal = \"_StructInternal\";\n/**\n *  Each input and output of a [[Fragment]] is an Array of **ParamType**.\n */\nexport class ParamType {\n    /**\n     *  The local name of the parameter (or ``\"\"`` if unbound)\n     */\n    name;\n    /**\n     *  The fully qualified type (e.g. ``\"address\"``, ``\"tuple(address)\"``,\n     *  ``\"uint256[3][]\"``)\n     */\n    type;\n    /**\n     *  The base type (e.g. ``\"address\"``, ``\"tuple\"``, ``\"array\"``)\n     */\n    baseType;\n    /**\n     *  True if the parameters is indexed.\n     *\n     *  For non-indexable types this is ``null``.\n     */\n    indexed;\n    /**\n     *  The components for the tuple.\n     *\n     *  For non-tuple types this is ``null``.\n     */\n    components;\n    /**\n     *  The array length, or ``-1`` for dynamic-lengthed arrays.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayLength;\n    /**\n     *  The type of each child in the array.\n     *\n     *  For non-array types this is ``null``.\n     */\n    arrayChildren;\n    /**\n     *  @private\n     */\n    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {\n        assertPrivate(guard, _guard, \"ParamType\");\n        Object.defineProperty(this, internal, { value: ParamTypeInternal });\n        if (components) {\n            components = Object.freeze(components.slice());\n        }\n        if (baseType === \"array\") {\n            if (arrayLength == null || arrayChildren == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (arrayLength != null || arrayChildren != null) {\n            throw new Error(\"\");\n        }\n        if (baseType === \"tuple\") {\n            if (components == null) {\n                throw new Error(\"\");\n            }\n        }\n        else if (components != null) {\n            throw new Error(\"\");\n        }\n        defineProperties(this, {\n            name, type, baseType, indexed, components, arrayLength, arrayChildren\n        });\n    }\n    /**\n     *  Return a string representation of this type.\n     *\n     *  For example,\n     *\n     *  ``sighash\" => \"(uint256,address)\"``\n     *\n     *  ``\"minimal\" => \"tuple(uint256,address) indexed\"``\n     *\n     *  ``\"full\" => \"tuple(uint256 foo, address bar) indexed baz\"``\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            const name = this.name || \"\";\n            if (this.isArray()) {\n                const result = JSON.parse(this.arrayChildren.format(\"json\"));\n                result.name = name;\n                result.type += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n                return JSON.stringify(result);\n            }\n            const result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.isTuple()) {\n                result.components = this.components.map((c) => JSON.parse(c.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.isArray()) {\n            result += this.arrayChildren.format(format);\n            result += `[${(this.arrayLength < 0 ? \"\" : String(this.arrayLength))}]`;\n        }\n        else {\n            if (this.isTuple()) {\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== \"sighash\") {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === \"full\" && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    /**\n     *  Returns true if %%this%% is an Array type.\n     *\n     *  This provides a type gaurd ensuring that [[arrayChildren]]\n     *  and [[arrayLength]] are non-null.\n     */\n    isArray() {\n        return (this.baseType === \"array\");\n    }\n    /**\n     *  Returns true if %%this%% is a Tuple type.\n     *\n     *  This provides a type gaurd ensuring that [[components]]\n     *  is non-null.\n     */\n    isTuple() {\n        return (this.baseType === \"tuple\");\n    }\n    /**\n     *  Returns true if %%this%% is an Indexable type.\n     *\n     *  This provides a type gaurd ensuring that [[indexed]]\n     *  is non-null.\n     */\n    isIndexable() {\n        return (this.indexed != null);\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, calling %%process%%\n     *  on each type, destructing the %%value%% recursively.\n     */\n    walk(value, process) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v) => (_this.arrayChildren.walk(v, process)));\n        }\n        if (this.isTuple()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid tuple value\");\n            }\n            if (value.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            const _this = this;\n            return value.map((v, i) => (_this.components[i].walk(v, process)));\n        }\n        return process(this.type, value);\n    }\n    #walkAsync(promises, value, process, setValue) {\n        if (this.isArray()) {\n            if (!Array.isArray(value)) {\n                throw new Error(\"invalid array value\");\n            }\n            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {\n                throw new Error(\"array is wrong length\");\n            }\n            const childType = this.arrayChildren;\n            const result = value.slice();\n            result.forEach((value, index) => {\n                childType.#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        if (this.isTuple()) {\n            const components = this.components;\n            // Convert the object into an array\n            let result;\n            if (Array.isArray(value)) {\n                result = value.slice();\n            }\n            else {\n                if (value == null || typeof (value) !== \"object\") {\n                    throw new Error(\"invalid tuple value\");\n                }\n                result = components.map((param) => {\n                    if (!param.name) {\n                        throw new Error(\"cannot use object value with unnamed components\");\n                    }\n                    if (!(param.name in value)) {\n                        throw new Error(`missing value for component ${param.name}`);\n                    }\n                    return value[param.name];\n                });\n            }\n            if (result.length !== this.components.length) {\n                throw new Error(\"array is wrong length\");\n            }\n            result.forEach((value, index) => {\n                components[index].#walkAsync(promises, value, process, (value) => {\n                    result[index] = value;\n                });\n            });\n            setValue(result);\n            return;\n        }\n        const result = process(this.type, value);\n        if (result.then) {\n            promises.push((async function () { setValue(await result); })());\n        }\n        else {\n            setValue(result);\n        }\n    }\n    /**\n     *  Walks the **ParamType** with %%value%%, asynchronously calling\n     *  %%process%% on each type, destructing the %%value%% recursively.\n     *\n     *  This can be used to resolve ENS names by walking and resolving each\n     *  ``\"address\"`` type.\n     */\n    async walkAsync(value, process) {\n        const promises = [];\n        const result = [value];\n        this.#walkAsync(promises, value, process, (value) => {\n            result[0] = value;\n        });\n        if (promises.length) {\n            await Promise.all(promises);\n        }\n        return result[0];\n    }\n    /**\n     *  Creates a new **ParamType** for %%obj%%.\n     *\n     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,\n     *  otherwise the ``indexed`` keyword will throw an error.\n     */\n    static from(obj, allowIndexed) {\n        if (ParamType.isParamType(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ParamType.from(lex(obj), allowIndexed);\n            }\n            catch (error) {\n                assertArgument(false, \"invalid param type\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            let type = \"\", baseType = \"\";\n            let comps = null;\n            if (consumeKeywords(obj, setify([\"tuple\"])).has(\"tuple\") || obj.peekType(\"OPEN_PAREN\")) {\n                // Tuple\n                baseType = \"tuple\";\n                comps = obj.popParams().map((t) => ParamType.from(t));\n                type = `tuple(${comps.map((c) => c.format()).join(\",\")})`;\n            }\n            else {\n                // Normal\n                type = verifyBasicType(obj.popType(\"TYPE\"));\n                baseType = type;\n            }\n            // Check for Array\n            let arrayChildren = null;\n            let arrayLength = null;\n            while (obj.length && obj.peekType(\"BRACKET\")) {\n                const bracket = obj.pop(); //arrays[i];\n                arrayChildren = new ParamType(_guard, \"\", type, baseType, null, comps, arrayLength, arrayChildren);\n                arrayLength = bracket.value;\n                type += bracket.text;\n                baseType = \"array\";\n                comps = null;\n            }\n            let indexed = null;\n            const keywords = consumeKeywords(obj, KwModifiers);\n            if (keywords.has(\"indexed\")) {\n                if (!allowIndexed) {\n                    throw new Error(\"\");\n                }\n                indexed = true;\n            }\n            const name = (obj.peekType(\"ID\") ? obj.pop().text : \"\");\n            if (obj.length) {\n                throw new Error(\"leftover tokens\");\n            }\n            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);\n        }\n        const name = obj.name;\n        assertArgument(!name || (typeof (name) === \"string\" && name.match(regexId)), \"invalid name\", \"obj.name\", name);\n        let indexed = obj.indexed;\n        if (indexed != null) {\n            assertArgument(allowIndexed, \"parameter cannot be indexed\", \"obj.indexed\", obj.indexed);\n            indexed = !!indexed;\n        }\n        let type = obj.type;\n        let arrayMatch = type.match(regexArrayType);\n        if (arrayMatch) {\n            const arrayLength = parseInt(arrayMatch[2] || \"-1\");\n            const arrayChildren = ParamType.from({\n                type: arrayMatch[1],\n                components: obj.components\n            });\n            return new ParamType(_guard, name || \"\", type, \"array\", indexed, null, arrayLength, arrayChildren);\n        }\n        if (type === \"tuple\" || type.startsWith(\"tuple(\" /* fix: ) */) || type.startsWith(\"(\" /* fix: ) */)) {\n            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;\n            const tuple = new ParamType(_guard, name || \"\", type, \"tuple\", indexed, comps, null, null);\n            // @TODO: use lexer to validate and normalize type\n            return tuple;\n        }\n        type = verifyBasicType(obj.type);\n        return new ParamType(_guard, name || \"\", type, type, indexed, null, null, null);\n    }\n    /**\n     *  Returns true if %%value%% is a **ParamType**.\n     */\n    static isParamType(value) {\n        return (value && value[internal] === ParamTypeInternal);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment from a parse ABI.\n */\nexport class Fragment {\n    /**\n     *  The type of the fragment.\n     */\n    type;\n    /**\n     *  The inputs for the fragment.\n     */\n    inputs;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs) {\n        assertPrivate(guard, _guard, \"Fragment\");\n        inputs = Object.freeze(inputs.slice());\n        defineProperties(this, { type, inputs });\n    }\n    /**\n     *  Creates a new **Fragment** for %%obj%%, wich can be any supported\n     *  ABI frgament type.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            // Try parsing JSON...\n            try {\n                Fragment.from(JSON.parse(obj));\n            }\n            catch (e) { }\n            // ...otherwise, use the human-readable lexer\n            return Fragment.from(lex(obj));\n        }\n        if (obj instanceof TokenString) {\n            // Human-readable ABI (already lexed)\n            const type = obj.peekKeyword(KwTypes);\n            switch (type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n        }\n        else if (typeof (obj) === \"object\") {\n            // JSON ABI\n            switch (obj.type) {\n                case \"constructor\": return ConstructorFragment.from(obj);\n                case \"error\": return ErrorFragment.from(obj);\n                case \"event\": return EventFragment.from(obj);\n                case \"fallback\":\n                case \"receive\":\n                    return FallbackFragment.from(obj);\n                case \"function\": return FunctionFragment.from(obj);\n                case \"struct\": return StructFragment.from(obj);\n            }\n            assert(false, `unsupported type: ${obj.type}`, \"UNSUPPORTED_OPERATION\", {\n                operation: \"Fragment.from\"\n            });\n        }\n        assertArgument(false, \"unsupported frgament object\", \"obj\", obj);\n    }\n    /**\n     *  Returns true if %%value%% is a [[ConstructorFragment]].\n     */\n    static isConstructor(value) {\n        return ConstructorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[ErrorFragment]].\n     */\n    static isError(value) {\n        return ErrorFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is an [[EventFragment]].\n     */\n    static isEvent(value) {\n        return EventFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[FunctionFragment]].\n     */\n    static isFunction(value) {\n        return FunctionFragment.isFragment(value);\n    }\n    /**\n     *  Returns true if %%value%% is a [[StructFragment]].\n     */\n    static isStruct(value) {\n        return StructFragment.isFragment(value);\n    }\n}\n/**\n *  An abstract class to represent An individual fragment\n *  which has a name from a parse ABI.\n */\nexport class NamedFragment extends Fragment {\n    /**\n     *  The name of the fragment.\n     */\n    name;\n    /**\n     *  @private\n     */\n    constructor(guard, type, name, inputs) {\n        super(guard, type, inputs);\n        assertArgument(typeof (name) === \"string\" && name.match(regexId), \"invalid identifier\", \"name\", name);\n        inputs = Object.freeze(inputs.slice());\n        defineProperties(this, { name });\n    }\n}\nfunction joinParams(format, params) {\n    return \"(\" + params.map((p) => p.format(format)).join((format === \"full\") ? \", \" : \",\") + \")\";\n}\n/**\n *  A Fragment which represents a //Custom Error//.\n */\nexport class ErrorFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"error\", name, inputs);\n        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });\n    }\n    /**\n     *  The Custom Error selector.\n     */\n    get selector() {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this fragment as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"error\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ErrorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ErrorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            return ErrorFragment.from(lex(obj));\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"error\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new ErrorFragment(_guard, name, inputs);\n        }\n        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **ErrorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ErrorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents an Event.\n */\nexport class EventFragment extends NamedFragment {\n    /**\n     *  Whether this event is anonymous.\n     */\n    anonymous;\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs, anonymous) {\n        super(guard, \"event\", name, inputs);\n        Object.defineProperty(this, internal, { value: EventFragmentInternal });\n        defineProperties(this, { anonymous });\n    }\n    /**\n     *  The Event topic hash.\n     */\n    get topicHash() {\n        return id(this.format(\"sighash\"));\n    }\n    /**\n     *  Returns a string representation of this event as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"event\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\" && this.anonymous) {\n            result.push(\"anonymous\");\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the topic hash for an event with %%name%% and %%params%%.\n     */\n    static getTopicHash(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new EventFragment(_guard, name, params, false);\n        return fragment.topicHash;\n    }\n    /**\n     *  Returns a new **EventFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (EventFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return EventFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid event fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"event\", obj);\n            const inputs = consumeParams(obj, true);\n            const anonymous = !!consumeKeywords(obj, setify([\"anonymous\"])).has(\"anonymous\");\n            consumeEoi(obj);\n            return new EventFragment(_guard, name, inputs, anonymous);\n        }\n        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is an\n     *  **EventFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === EventFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a constructor.\n */\nexport class ConstructorFragment extends Fragment {\n    /**\n     *  Whether the constructor can receive an endowment.\n     */\n    payable;\n    /**\n     *  The recommended gas limit for deployment or ``null``.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, type, inputs, payable, gas) {\n        super(guard, type, inputs);\n        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });\n        defineProperties(this, { payable, gas });\n    }\n    /**\n     *  Returns a string representation of this constructor as %%format%%.\n     */\n    format(format) {\n        assert(format != null && format !== \"sighash\", \"cannot format a constructor for sighash\", \"UNSUPPORTED_OPERATION\", { operation: \"format(sighash)\" });\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: (this.payable ? \"payable\" : \"undefined\"),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))\n            });\n        }\n        const result = [`constructor${joinParams(format, this.inputs)}`];\n        if (this.payable) {\n            result.push(\"payable\");\n        }\n        if (this.gas != null) {\n            result.push(`@${this.gas.toString()}`);\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Returns a new **ConstructorFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (ConstructorFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return ConstructorFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid constuctor fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            consumeKeywords(obj, setify([\"constructor\"]));\n            const inputs = consumeParams(obj);\n            const payable = !!consumeKeywords(obj, KwVisibDeploy).has(\"payable\");\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new ConstructorFragment(_guard, \"constructor\", inputs, payable, gas);\n        }\n        return new ConstructorFragment(_guard, \"constructor\", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **ConstructorFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === ConstructorFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FallbackFragment extends Fragment {\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    constructor(guard, inputs, payable) {\n        super(guard, \"fallback\", inputs);\n        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });\n        defineProperties(this, { payable });\n    }\n    /**\n     *  Returns a string representation of this fallback as %%format%%.\n     */\n    format(format) {\n        const type = ((this.inputs.length === 0) ? \"receive\" : \"fallback\");\n        if (format === \"json\") {\n            const stateMutability = (this.payable ? \"payable\" : \"nonpayable\");\n            return JSON.stringify({ type, stateMutability });\n        }\n        return `${type}()${this.payable ? \" payable\" : \"\"}`;\n    }\n    /**\n     *  Returns a new **FallbackFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FallbackFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FallbackFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid fallback fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const errorObj = obj.toString();\n            const topIsValid = obj.peekKeyword(setify([\"fallback\", \"receive\"]));\n            assertArgument(topIsValid, \"type must be fallback or receive\", \"obj\", errorObj);\n            const type = obj.popKeyword(setify([\"fallback\", \"receive\"]));\n            // receive()\n            if (type === \"receive\") {\n                const inputs = consumeParams(obj);\n                assertArgument(inputs.length === 0, `receive cannot have arguments`, \"obj.inputs\", inputs);\n                consumeKeywords(obj, setify([\"payable\"]));\n                consumeEoi(obj);\n                return new FallbackFragment(_guard, [], true);\n            }\n            // fallback() [payable]\n            // fallback(bytes) [payable] returns (bytes)\n            let inputs = consumeParams(obj);\n            if (inputs.length) {\n                assertArgument(inputs.length === 1 && inputs[0].type === \"bytes\", \"invalid fallback inputs\", \"obj.inputs\", inputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            else {\n                inputs = [ParamType.from(\"bytes\")];\n            }\n            const mutability = consumeMutability(obj);\n            assertArgument(mutability === \"nonpayable\" || mutability === \"payable\", \"fallback cannot be constants\", \"obj.stateMutability\", mutability);\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                const outputs = consumeParams(obj);\n                assertArgument(outputs.length === 1 && outputs[0].type === \"bytes\", \"invalid fallback outputs\", \"obj.outputs\", outputs.map((i) => i.format(\"minimal\")).join(\", \"));\n            }\n            consumeEoi(obj);\n            return new FallbackFragment(_guard, inputs, mutability === \"payable\");\n        }\n        if (obj.type === \"receive\") {\n            return new FallbackFragment(_guard, [], true);\n        }\n        if (obj.type === \"fallback\") {\n            const inputs = [ParamType.from(\"bytes\")];\n            const payable = (obj.stateMutability === \"payable\");\n            return new FallbackFragment(_guard, inputs, payable);\n        }\n        assertArgument(false, \"invalid fallback description\", \"obj\", obj);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FallbackFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FallbackFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a method.\n */\nexport class FunctionFragment extends NamedFragment {\n    /**\n     *  If the function is constant (e.g. ``pure`` or ``view`` functions).\n     */\n    constant;\n    /**\n     *  The returned types for the result of calling this function.\n     */\n    outputs;\n    /**\n     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``\n     *  or ``pure``)\n     */\n    stateMutability;\n    /**\n     *  If the function can be sent value during invocation.\n     */\n    payable;\n    /**\n     *  The recommended gas limit to send when calling this function.\n     */\n    gas;\n    /**\n     *  @private\n     */\n    constructor(guard, name, stateMutability, inputs, outputs, gas) {\n        super(guard, \"function\", name, inputs);\n        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });\n        outputs = Object.freeze(outputs.slice());\n        const constant = (stateMutability === \"view\" || stateMutability === \"pure\");\n        const payable = (stateMutability === \"payable\");\n        defineProperties(this, { constant, gas, outputs, payable, stateMutability });\n    }\n    /**\n     *  The Function selector.\n     */\n    get selector() {\n        return id(this.format(\"sighash\")).substring(0, 10);\n    }\n    /**\n     *  Returns a string representation of this function as %%format%%.\n     */\n    format(format) {\n        if (format == null) {\n            format = \"sighash\";\n        }\n        if (format === \"json\") {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: ((this.gas != null) ? this.gas : undefined),\n                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),\n                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),\n            });\n        }\n        const result = [];\n        if (format !== \"sighash\") {\n            result.push(\"function\");\n        }\n        result.push(this.name + joinParams(format, this.inputs));\n        if (format !== \"sighash\") {\n            if (this.stateMutability !== \"nonpayable\") {\n                result.push(this.stateMutability);\n            }\n            if (this.outputs && this.outputs.length) {\n                result.push(\"returns\");\n                result.push(joinParams(format, this.outputs));\n            }\n            if (this.gas != null) {\n                result.push(`@${this.gas.toString()}`);\n            }\n        }\n        return result.join(\" \");\n    }\n    /**\n     *  Return the selector for a function with %%name%% and %%params%%.\n     */\n    static getSelector(name, params) {\n        params = (params || []).map((p) => ParamType.from(p));\n        const fragment = new FunctionFragment(_guard, name, \"view\", params, [], null);\n        return fragment.selector;\n    }\n    /**\n     *  Returns a new **FunctionFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (FunctionFragment.isFragment(obj)) {\n            return obj;\n        }\n        if (typeof (obj) === \"string\") {\n            try {\n                return FunctionFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid function fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"function\", obj);\n            const inputs = consumeParams(obj);\n            const mutability = consumeMutability(obj);\n            let outputs = [];\n            if (consumeKeywords(obj, setify([\"returns\"])).has(\"returns\")) {\n                outputs = consumeParams(obj);\n            }\n            const gas = consumeGas(obj);\n            consumeEoi(obj);\n            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);\n        }\n        let stateMutability = obj.stateMutability;\n        // Use legacy Solidity ABI logic if stateMutability is missing\n        if (stateMutability == null) {\n            stateMutability = \"payable\";\n            if (typeof (obj.constant) === \"boolean\") {\n                stateMutability = \"view\";\n                if (!obj.constant) {\n                    stateMutability = \"payable\";\n                    if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                        stateMutability = \"nonpayable\";\n                    }\n                }\n            }\n            else if (typeof (obj.payable) === \"boolean\" && !obj.payable) {\n                stateMutability = \"nonpayable\";\n            }\n        }\n        // @TODO: verifyState for stateMutability (e.g. throw if\n        //        payable: false but stateMutability is \"nonpayable\")\n        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);\n    }\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **FunctionFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === FunctionFragmentInternal);\n    }\n}\n/**\n *  A Fragment which represents a structure.\n */\nexport class StructFragment extends NamedFragment {\n    /**\n     *  @private\n     */\n    constructor(guard, name, inputs) {\n        super(guard, \"struct\", name, inputs);\n        Object.defineProperty(this, internal, { value: StructFragmentInternal });\n    }\n    /**\n     *  Returns a string representation of this struct as %%format%%.\n     */\n    format() {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Returns a new **StructFragment** for %%obj%%.\n     */\n    static from(obj) {\n        if (typeof (obj) === \"string\") {\n            try {\n                return StructFragment.from(lex(obj));\n            }\n            catch (error) {\n                assertArgument(false, \"invalid struct fragment\", \"obj\", obj);\n            }\n        }\n        else if (obj instanceof TokenString) {\n            const name = consumeName(\"struct\", obj);\n            const inputs = consumeParams(obj);\n            consumeEoi(obj);\n            return new StructFragment(_guard, name, inputs);\n        }\n        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);\n    }\n    // @TODO: fix this return type\n    /**\n     *  Returns ``true`` and provides a type guard if %%value%% is a\n     *  **StructFragment**.\n     */\n    static isFragment(value) {\n        return (value && value[internal] === StructFragmentInternal);\n    }\n}\n//# sourceMappingURL=fragments.js.map","/**\n *  When sending values to or receiving values from a [[Contract]], the\n *  data is generally encoded using the [ABI standard](link-solc-abi).\n *\n *  The AbiCoder provides a utility to encode values to ABI data and\n *  decode values from ABI data.\n *\n *  Most of the time, developers should favour the [[Contract]] class,\n *  which further abstracts a lot of the finer details of ABI data.\n *\n *  @_section api/abi/abi-coder:ABI Encoding\n */\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { assertArgumentCount, assertArgument } from \"../utils/index.js\";\nimport { Reader, Writer } from \"./coders/abstract-coder.js\";\nimport { AddressCoder } from \"./coders/address.js\";\nimport { ArrayCoder } from \"./coders/array.js\";\nimport { BooleanCoder } from \"./coders/boolean.js\";\nimport { BytesCoder } from \"./coders/bytes.js\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes.js\";\nimport { NullCoder } from \"./coders/null.js\";\nimport { NumberCoder } from \"./coders/number.js\";\nimport { StringCoder } from \"./coders/string.js\";\nimport { TupleCoder } from \"./coders/tuple.js\";\nimport { ParamType } from \"./fragments.js\";\nimport { getAddress } from \"../address/index.js\";\nimport { getBytes, hexlify, makeError } from \"../utils/index.js\";\n// https://docs.soliditylang.org/en/v0.8.17/control-structures.html\nconst PanicReasons = new Map();\nPanicReasons.set(0x00, \"GENERIC_PANIC\");\nPanicReasons.set(0x01, \"ASSERT_FALSE\");\nPanicReasons.set(0x11, \"OVERFLOW\");\nPanicReasons.set(0x12, \"DIVIDE_BY_ZERO\");\nPanicReasons.set(0x21, \"ENUM_RANGE_ERROR\");\nPanicReasons.set(0x22, \"BAD_STORAGE_DATA\");\nPanicReasons.set(0x31, \"STACK_UNDERFLOW\");\nPanicReasons.set(0x32, \"ARRAY_RANGE_ERROR\");\nPanicReasons.set(0x41, \"OUT_OF_MEMORY\");\nPanicReasons.set(0x51, \"UNINITIALIZED_FUNCTION_CALL\");\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nlet defaultCoder = null;\nlet defaultMaxInflation = 1024;\nfunction getBuiltinCallException(action, tx, data, abiCoder) {\n    let message = \"missing revert data\";\n    let reason = null;\n    const invocation = null;\n    let revert = null;\n    if (data) {\n        message = \"execution reverted\";\n        const bytes = getBytes(data);\n        data = hexlify(data);\n        if (bytes.length === 0) {\n            message += \" (no data present; likely require(false) occurred\";\n            reason = \"require(false)\";\n        }\n        else if (bytes.length % 32 !== 4) {\n            message += \" (could not decode reason; invalid data length)\";\n        }\n        else if (hexlify(bytes.slice(0, 4)) === \"0x08c379a0\") {\n            // Error(string)\n            try {\n                reason = abiCoder.decode([\"string\"], bytes.slice(4))[0];\n                revert = {\n                    signature: \"Error(string)\",\n                    name: \"Error\",\n                    args: [reason]\n                };\n                message += `: ${JSON.stringify(reason)}`;\n            }\n            catch (error) {\n                message += \" (could not decode reason; invalid string data)\";\n            }\n        }\n        else if (hexlify(bytes.slice(0, 4)) === \"0x4e487b71\") {\n            // Panic(uint256)\n            try {\n                const code = Number(abiCoder.decode([\"uint256\"], bytes.slice(4))[0]);\n                revert = {\n                    signature: \"Panic(uint256)\",\n                    name: \"Panic\",\n                    args: [code]\n                };\n                reason = `Panic due to ${PanicReasons.get(code) || \"UNKNOWN\"}(${code})`;\n                message += `: ${reason}`;\n            }\n            catch (error) {\n                message += \" (could not decode panic code)\";\n            }\n        }\n        else {\n            message += \" (unknown custom error)\";\n        }\n    }\n    const transaction = {\n        to: (tx.to ? getAddress(tx.to) : null),\n        data: (tx.data || \"0x\")\n    };\n    if (tx.from) {\n        transaction.from = getAddress(tx.from);\n    }\n    return makeError(message, \"CALL_EXCEPTION\", {\n        action, data, reason, transaction, invocation, revert\n    });\n}\n/**\n *  The **AbiCoder** is a low-level class responsible for encoding JavaScript\n *  values into binary data and decoding binary data into JavaScript values.\n */\nexport class AbiCoder {\n    #getCoder(param) {\n        if (param.isArray()) {\n            return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);\n        }\n        if (param.isTuple()) {\n            return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);\n        }\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            assertArgument(size !== 0 && size <= 256 && (size % 8) === 0, \"invalid \" + match[1] + \" bit length\", \"param\", param);\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            assertArgument(size !== 0 && size <= 32, \"invalid bytes length\", \"param\", param);\n            return new FixedBytesCoder(size, param.name);\n        }\n        assertArgument(false, \"invalid type\", \"type\", param.type);\n    }\n    /**\n     *  Get the default values for the given %%types%%.\n     *\n     *  For example, a ``uint`` is by default ``0`` and ``bool``\n     *  is by default ``false``.\n     */\n    getDefaultValue(types) {\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    /**\n     *  Encode the %%values%% as the %%types%% into ABI data.\n     *\n     *  @returns DataHexstring\n     */\n    encode(types, values) {\n        assertArgumentCount(values.length, types.length, \"types/values length mismatch\");\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n        const writer = new Writer();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    /**\n     *  Decode the ABI %%data%% as the %%types%% into values.\n     *\n     *  If %%loose%% decoding is enabled, then strict padding is\n     *  not enforced. Some older versions of Solidity incorrectly\n     *  padded event data emitted from ``external`` functions.\n     */\n    decode(types, data, loose) {\n        const coders = types.map((type) => this.#getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(new Reader(data, loose, defaultMaxInflation));\n    }\n    static _setDefaultMaxInflation(value) {\n        assertArgument(typeof (value) === \"number\" && Number.isInteger(value), \"invalid defaultMaxInflation factor\", \"value\", value);\n        defaultMaxInflation = value;\n    }\n    /**\n     *  Returns the shared singleton instance of a default [[AbiCoder]].\n     *\n     *  On the first call, the instance is created internally.\n     */\n    static defaultAbiCoder() {\n        if (defaultCoder == null) {\n            defaultCoder = new AbiCoder();\n        }\n        return defaultCoder;\n    }\n    /**\n     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given\n     *  result %%data%% for the [[CallExceptionAction]] %%action%% against\n     *  the Transaction %%tx%%.\n     */\n    static getBuiltinCallException(action, tx, data) {\n        return getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());\n    }\n}\n//# sourceMappingURL=abi-coder.js.map","/**\n *  The Interface class is a low-level class that accepts an\n *  ABI and provides all the necessary functionality to encode\n *  and decode paramaters to and results from methods, events\n *  and errors.\n *\n *  It also provides several convenience methods to automatically\n *  search and find matching transactions and events to parse them.\n *\n *  @_subsection api/abi:Interfaces  [interfaces]\n */\nimport { keccak256 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { concat, dataSlice, getBigInt, getBytes, getBytesCopy, hexlify, zeroPadBytes, zeroPadValue, isHexString, defineProperties, assertArgument, toBeHex, assert } from \"../utils/index.js\";\nimport { AbiCoder } from \"./abi-coder.js\";\nimport { checkResultErrors, Result } from \"./coders/abstract-coder.js\";\nimport { ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType } from \"./fragments.js\";\nimport { Typed } from \"./typed.js\";\nexport { checkResultErrors, Result };\n/**\n *  When using the [[Interface-parseLog]] to automatically match a Log to its event\n *  for parsing, a **LogDescription** is returned.\n */\nexport class LogDescription {\n    /**\n     *  The matching fragment for the ``topic0``.\n     */\n    fragment;\n    /**\n     *  The name of the Event.\n     */\n    name;\n    /**\n     *  The full Event signature.\n     */\n    signature;\n    /**\n     *  The topic hash for the Event.\n     */\n    topic;\n    /**\n     *  The arguments passed into the Event with ``emit``.\n     */\n    args;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, topic, args) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties(this, {\n            fragment, name, signature, topic, args\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseTransaction]] to automatically match\n *  a transaction data to its function for parsing,\n *  a **TransactionDescription** is returned.\n */\nexport class TransactionDescription {\n    /**\n     *  The matching fragment from the transaction ``data``.\n     */\n    fragment;\n    /**\n     *  The name of the Function from the transaction ``data``.\n     */\n    name;\n    /**\n     *  The arguments passed to the Function from the transaction ``data``.\n     */\n    args;\n    /**\n     *  The full Function signature from the transaction ``data``.\n     */\n    signature;\n    /**\n     *  The selector for the Function from the transaction ``data``.\n     */\n    selector;\n    /**\n     *  The ``value`` (in wei) from the transaction.\n     */\n    value;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args, value) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties(this, {\n            fragment, name, args, signature, selector, value\n        });\n    }\n}\n/**\n *  When using the [[Interface-parseError]] to automatically match an\n *  error for a call result for parsing, an **ErrorDescription** is returned.\n */\nexport class ErrorDescription {\n    /**\n     *  The matching fragment.\n     */\n    fragment;\n    /**\n     *  The name of the Error.\n     */\n    name;\n    /**\n     *  The arguments passed to the Error with ``revert``.\n     */\n    args;\n    /**\n     *  The full Error signature.\n     */\n    signature;\n    /**\n     *  The selector for the Error.\n     */\n    selector;\n    /**\n     *  @_ignore:\n     */\n    constructor(fragment, selector, args) {\n        const name = fragment.name, signature = fragment.format();\n        defineProperties(this, {\n            fragment, name, args, signature, selector\n        });\n    }\n}\n/**\n *  An **Indexed** is used as a value when a value that does not\n *  fit within a topic (i.e. not a fixed-length, 32-byte type). It\n *  is the ``keccak256`` of the value, and used for types such as\n *  arrays, tuples, bytes and strings.\n */\nexport class Indexed {\n    /**\n     *  The ``keccak256`` of the value logged.\n     */\n    hash;\n    /**\n     *  @_ignore:\n     */\n    _isIndexed;\n    /**\n     *  Returns ``true`` if %%value%% is an **Indexed**.\n     *\n     *  This provides a Type Guard for property access.\n     */\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n    /**\n     *  @_ignore:\n     */\n    constructor(hash) {\n        defineProperties(this, { hash, _isIndexed: true });\n    }\n}\n// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require\nconst PanicReasons = {\n    \"0\": \"generic panic\",\n    \"1\": \"assert(false)\",\n    \"17\": \"arithmetic overflow\",\n    \"18\": \"division or modulo by zero\",\n    \"33\": \"enum overflow\",\n    \"34\": \"invalid encoded storage byte array accessed\",\n    \"49\": \"out-of-bounds array access; popping on an empty array\",\n    \"50\": \"out-of-bounds access of an array or bytesN\",\n    \"65\": \"out of memory\",\n    \"81\": \"uninitialized function\",\n};\nconst BuiltinErrors = {\n    \"0x08c379a0\": {\n        signature: \"Error(string)\",\n        name: \"Error\",\n        inputs: [\"string\"],\n        reason: (message) => {\n            return `reverted with reason string ${JSON.stringify(message)}`;\n        }\n    },\n    \"0x4e487b71\": {\n        signature: \"Panic(uint256)\",\n        name: \"Panic\",\n        inputs: [\"uint256\"],\n        reason: (code) => {\n            let reason = \"unknown panic code\";\n            if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {\n                reason = PanicReasons[code.toString()];\n            }\n            return `reverted with panic code 0x${code.toString(16)} (${reason})`;\n        }\n    }\n};\n/**\n *  An Interface abstracts many of the low-level details for\n *  encoding and decoding the data on the blockchain.\n *\n *  An ABI provides information on how to encode data to send to\n *  a Contract, how to decode the results and events and how to\n *  interpret revert errors.\n *\n *  The ABI can be specified by [any supported format](InterfaceAbi).\n */\nexport class Interface {\n    /**\n     *  All the Contract ABI members (i.e. methods, events, errors, etc).\n     */\n    fragments;\n    /**\n     *  The Contract constructor.\n     */\n    deploy;\n    /**\n     *  The Fallback method, if any.\n     */\n    fallback;\n    /**\n     *  If receiving ether is supported.\n     */\n    receive;\n    #errors;\n    #events;\n    #functions;\n    //    #structs: Map<string, StructFragment>;\n    #abiCoder;\n    /**\n     *  Create a new Interface for the %%fragments%%.\n     */\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        this.#functions = new Map();\n        this.#errors = new Map();\n        this.#events = new Map();\n        //        this.#structs = new Map();\n        const frags = [];\n        for (const a of abi) {\n            try {\n                frags.push(Fragment.from(a));\n            }\n            catch (error) {\n                console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`, error.message);\n            }\n        }\n        defineProperties(this, {\n            fragments: Object.freeze(frags)\n        });\n        let fallback = null;\n        let receive = false;\n        this.#abiCoder = this.getAbiCoder();\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment, index) => {\n            let bucket;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        console.log(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineProperties(this, { deploy: fragment });\n                    return;\n                case \"fallback\":\n                    if (fragment.inputs.length === 0) {\n                        receive = true;\n                    }\n                    else {\n                        assertArgument(!fallback || fragment.payable !== fallback.payable, \"conflicting fallback fragments\", `fragments[${index}]`, fragment);\n                        fallback = fragment;\n                        receive = fallback.payable;\n                    }\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.#functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.#events;\n                    break;\n                case \"error\":\n                    bucket = this.#errors;\n                    break;\n                default:\n                    return;\n            }\n            // Two identical entries; ignore it\n            const signature = fragment.format();\n            if (bucket.has(signature)) {\n                return;\n            }\n            bucket.set(signature, fragment);\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineProperties(this, {\n                deploy: ConstructorFragment.from(\"constructor()\")\n            });\n        }\n        defineProperties(this, { fallback, receive });\n    }\n    /**\n     *  Returns the entire Human-Readable ABI, as an array of\n     *  signatures, optionally as %%minimal%% strings, which\n     *  removes parameter names and unneceesary spaces.\n     */\n    format(minimal) {\n        const format = (minimal ? \"minimal\" : \"full\");\n        const abi = this.fragments.map((f) => f.format(format));\n        return abi;\n    }\n    /**\n     *  Return the JSON-encoded ABI. This is the format Solidiy\n     *  returns.\n     */\n    formatJson() {\n        const abi = this.fragments.map((f) => f.format(\"json\"));\n        // We need to re-bundle the JSON fragments a bit\n        return JSON.stringify(abi.map((j) => JSON.parse(j)));\n    }\n    /**\n     *  The ABI coder that will be used to encode and decode binary\n     *  data.\n     */\n    getAbiCoder() {\n        return AbiCoder.defaultAbiCoder();\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    #getFunction(key, values, forceUnique) {\n        // Selector\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            for (const fragment of this.#functions.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#functions) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                const lastValue = (values.length > 0) ? values[values.length - 1] : null;\n                let valueLength = values.length;\n                let allowOptions = true;\n                if (Typed.isTyped(lastValue) && lastValue.type === \"overrides\") {\n                    allowOptions = false;\n                    valueLength--;\n                }\n                // Remove all matches that don't have a compatible length. The args\n                // may contain an overrides, so the match may have n or n - 1 parameters\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs.length;\n                    if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // We are past the inputs\n                        if (j >= inputs.length) {\n                            if (values[j].type === \"overrides\") {\n                                continue;\n                            }\n                            matching.splice(i, 1);\n                            break;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            // We found a single matching signature with an overrides, but the\n            // last value is something that cannot possibly be an options\n            if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {\n                const lastArg = values[values.length - 1];\n                if (lastArg == null || Array.isArray(lastArg) || typeof (lastArg) !== \"object\") {\n                    matching.splice(0, 1);\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#functions.get(FunctionFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the function name for %%key%%, which may be a function selector,\n     *  function name or function signature that belongs to the ABI.\n     */\n    getFunctionName(key) {\n        const fragment = this.#getFunction(key, null, false);\n        assertArgument(fragment, \"no matching function\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (a function selector, function name or\n     *  function signature) is present in the ABI.\n     *\n     *  In the case of a function name, the name may be ambiguous, so\n     *  accessing the [[FunctionFragment]] may require refinement.\n     */\n    hasFunction(key) {\n        return !!this.#getFunction(key, null, false);\n    }\n    /**\n     *  Get the [[FunctionFragment]] for %%key%%, which may be a function\n     *  selector, function name or function signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple functions match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single function in\n     *  the ABI, this will throw.\n     */\n    getFunction(key, values) {\n        return this.#getFunction(key, values || null, true);\n    }\n    /**\n     *  Iterate over all functions, calling %%callback%%, sorted by their name.\n     */\n    forEachFunction(callback) {\n        const names = Array.from(this.#functions.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#functions.get(name)), i);\n        }\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    #getEvent(key, values, forceUnique) {\n        // EventTopic\n        if (isHexString(key)) {\n            const eventTopic = key.toLowerCase();\n            for (const fragment of this.#events.values()) {\n                if (eventTopic === fragment.topicHash) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#events) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (values) {\n                // Remove all matches that don't have a compatible length.\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    if (matching[i].inputs.length < values.length) {\n                        matching.splice(i, 1);\n                    }\n                }\n                // Remove all matches that don't match the Typed signature\n                for (let i = matching.length - 1; i >= 0; i--) {\n                    const inputs = matching[i].inputs;\n                    for (let j = 0; j < values.length; j++) {\n                        // Not a typed value\n                        if (!Typed.isTyped(values[j])) {\n                            continue;\n                        }\n                        // Make sure the value type matches the input type\n                        if (values[j].type !== inputs[j].baseType) {\n                            matching.splice(i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            if (matching.length === 0) {\n                return null;\n            }\n            if (matching.length > 1 && forceUnique) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, \"key\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.#events.get(EventFragment.from(key).format());\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Get the event name for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     */\n    getEventName(key) {\n        const fragment = this.#getEvent(key, null, false);\n        assertArgument(fragment, \"no matching event\", \"key\", key);\n        return fragment.name;\n    }\n    /**\n     *  Returns true if %%key%% (an event topic hash, event name or\n     *  event signature) is present in the ABI.\n     *\n     *  In the case of an event name, the name may be ambiguous, so\n     *  accessing the [[EventFragment]] may require refinement.\n     */\n    hasEvent(key) {\n        return !!this.#getEvent(key, null, false);\n    }\n    /**\n     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,\n     *  event name or event signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple events match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single event in\n     *  the ABI, this will throw.\n     */\n    getEvent(key, values) {\n        return this.#getEvent(key, values || null, true);\n    }\n    /**\n     *  Iterate over all events, calling %%callback%%, sorted by their name.\n     */\n    forEachEvent(callback) {\n        const names = Array.from(this.#events.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#events.get(name)), i);\n        }\n    }\n    /**\n     *  Get the [[ErrorFragment]] for %%key%%, which may be an error\n     *  selector, error name or error signature that belongs to the ABI.\n     *\n     *  If %%values%% is provided, it will use the Typed API to handle\n     *  ambiguous cases where multiple errors match by name.\n     *\n     *  If the %%key%% and %%values%% do not refine to a single error in\n     *  the ABI, this will throw.\n     */\n    getError(key, values) {\n        if (isHexString(key)) {\n            const selector = key.toLowerCase();\n            if (BuiltinErrors[selector]) {\n                return ErrorFragment.from(BuiltinErrors[selector].signature);\n            }\n            for (const fragment of this.#errors.values()) {\n                if (selector === fragment.selector) {\n                    return fragment;\n                }\n            }\n            return null;\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (key.indexOf(\"(\") === -1) {\n            const matching = [];\n            for (const [name, fragment] of this.#errors) {\n                if (name.split(\"(\" /* fix:) */)[0] === key) {\n                    matching.push(fragment);\n                }\n            }\n            if (matching.length === 0) {\n                if (key === \"Error\") {\n                    return ErrorFragment.from(\"error Error(string)\");\n                }\n                if (key === \"Panic\") {\n                    return ErrorFragment.from(\"error Panic(uint256)\");\n                }\n                return null;\n            }\n            else if (matching.length > 1) {\n                const matchStr = matching.map((m) => JSON.stringify(m.format())).join(\", \");\n                assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, \"name\", key);\n            }\n            return matching[0];\n        }\n        // Normalize the signature and lookup the function\n        key = ErrorFragment.from(key).format();\n        if (key === \"Error(string)\") {\n            return ErrorFragment.from(\"error Error(string)\");\n        }\n        if (key === \"Panic(uint256)\") {\n            return ErrorFragment.from(\"error Panic(uint256)\");\n        }\n        const result = this.#errors.get(key);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     *  Iterate over all errors, calling %%callback%%, sorted by their name.\n     */\n    forEachError(callback) {\n        const names = Array.from(this.#errors.keys());\n        names.sort((a, b) => a.localeCompare(b));\n        for (let i = 0; i < names.length; i++) {\n            const name = names[i];\n            callback((this.#errors.get(name)), i);\n        }\n    }\n    // Get the 4-byte selector used by Solidity to identify a function\n    /*\ngetSelector(fragment: ErrorFragment | FunctionFragment): string {\n    if (typeof(fragment) === \"string\") {\n        const matches: Array<Fragment> = [ ];\n\n        try { matches.push(this.getFunction(fragment)); } catch (error) { }\n        try { matches.push(this.getError(<string>fragment)); } catch (_) { }\n\n        if (matches.length === 0) {\n            logger.throwArgumentError(\"unknown fragment\", \"key\", fragment);\n        } else if (matches.length > 1) {\n            logger.throwArgumentError(\"ambiguous fragment matches function and error\", \"key\", fragment);\n        }\n\n        fragment = matches[0];\n    }\n\n    return dataSlice(id(fragment.format()), 0, 4);\n}\n    */\n    // Get the 32-byte topic hash used by Solidity to identify an event\n    /*\n    getEventTopic(fragment: EventFragment): string {\n        //if (typeof(fragment) === \"string\") { fragment = this.getEvent(eventFragment); }\n        return id(fragment.format());\n    }\n    */\n    _decodeParams(params, data) {\n        return this.#abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this.#abiCoder.encode(params, values);\n    }\n    /**\n     *  Encodes a ``tx.data`` object for deploying the Contract with\n     *  the %%values%% as the constructor arguments.\n     */\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified error (see [[getError]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n    /**\n     *  Encodes the transaction revert data for a call result that\n     *  reverted from the the Contract with the sepcified %%error%%\n     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getError(fragment);\n            assertArgument(f, \"unknown error\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the %%data%% from a transaction ``tx.data`` for\n     *  the function specified (see [[getFunction]] for valid values\n     *  for %%fragment%%).\n     *\n     *  Most developers should prefer the [[parseTransaction]] method\n     *  instead, which will automatically detect the fragment.\n     */\n    decodeFunctionData(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        assertArgument(dataSlice(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, \"data\", data);\n        return this._decodeParams(fragment.inputs, dataSlice(data, 4));\n    }\n    /**\n     *  Encodes the ``tx.data`` for a transaction that calls the function\n     *  specified (see [[getFunction]] for valid values for %%fragment%%) with\n     *  the %%values%%.\n     */\n    encodeFunctionData(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return concat([\n            fragment.selector,\n            this._encodeParams(fragment.inputs, values || [])\n        ]);\n    }\n    /**\n     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values for\n     *  %%key%%).\n     *\n     *  Most developers should prefer the [[parseCallResult]] method instead,\n     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the\n     *  corresponding error.\n     */\n    decodeFunctionResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        let message = \"invalid length for result data\";\n        const bytes = getBytesCopy(data);\n        if ((bytes.length % 32) === 0) {\n            try {\n                return this.#abiCoder.decode(fragment.outputs, bytes);\n            }\n            catch (error) {\n                message = \"could not decode result data\";\n            }\n        }\n        // Call returned data with no error, but the data is junk\n        assert(false, message, \"BAD_DATA\", {\n            value: hexlify(bytes),\n            info: { method: fragment.name, signature: fragment.format() }\n        });\n    }\n    makeError(_data, tx) {\n        const data = getBytes(_data, \"data\");\n        const error = AbiCoder.getBuiltinCallException(\"call\", tx, data);\n        // Not a built-in error; try finding a custom error\n        const customPrefix = \"execution reverted (unknown custom error)\";\n        if (error.message.startsWith(customPrefix)) {\n            const selector = hexlify(data.slice(0, 4));\n            const ef = this.getError(selector);\n            if (ef) {\n                try {\n                    const args = this.#abiCoder.decode(ef.inputs, data.slice(4));\n                    error.revert = {\n                        name: ef.name, signature: ef.format(), args\n                    };\n                    error.reason = error.revert.signature;\n                    error.message = `execution reverted: ${error.reason}`;\n                }\n                catch (e) {\n                    error.message = `execution reverted (coult not decode custom error)`;\n                }\n            }\n        }\n        // Add the invocation, if available\n        const parsed = this.parseTransaction(tx);\n        if (parsed) {\n            error.invocation = {\n                method: parsed.name,\n                signature: parsed.signature,\n                args: parsed.args\n            };\n        }\n        return error;\n    }\n    /**\n     *  Encodes the result data (e.g. from an ``eth_call``) for the\n     *  specified function (see [[getFunction]] for valid values\n     *  for %%fragment%%) with %%values%%.\n     *\n     *  This is generally not used by most developers, unless trying to mock\n     *  a result from a Contract.\n     */\n    encodeFunctionResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getFunction(fragment);\n            assertArgument(f, \"unknown function\", \"fragment\", fragment);\n            fragment = f;\n        }\n        return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));\n    }\n    /*\n        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {\n            const promises: Array<Promise<>> = [ ];\n            const process = function(type: ParamType, value: any): any {\n                if (type.baseType === \"array\") {\n                    return descend(type.child\n                }\n                if (type. === \"address\") {\n                }\n            };\n    \n            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {\n                if (inputs.length !== values.length) { throw new Error(\"length mismatch\"); }\n                \n            };\n    \n            const result: Array<any> = [ ];\n            values.forEach((value, index) => {\n                if (value == null) {\n                    topics.push(null);\n                } else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                    logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n                } else if (Array.isArray(value)) {\n                    topics.push(value.map((value) => encodeTopic(param, value)));\n                } else {\n                    topics.push(encodeTopic(param, value));\n                }\n            });\n        }\n    */\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        assert(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, \"UNEXPECTED_ARGUMENT\", { count: values.length, expectedCount: fragment.inputs.length });\n        const topics = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        // @TODO: Use the coders for this; to properly support tuples, etc.\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return id(value);\n            }\n            else if (param.type === \"bytes\") {\n                return keccak256(hexlify(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            else if (param.type.match(/^u?int/)) {\n                value = toBeHex(value); // @TODO: Should this toTwos??\n            }\n            else if (param.type.match(/^bytes/)) {\n                value = zeroPadBytes(value, 32);\n            }\n            else if (param.type === \"address\") {\n                // Check addresses are valid\n                this.#abiCoder.encode([\"address\"], [value]);\n            }\n            return zeroPadValue(hexlify(value), 32);\n        };\n        values.forEach((value, index) => {\n            const param = fragment.inputs[index];\n            if (!param.indexed) {\n                assertArgument(value == null, \"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                assertArgument(false, \"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!fragment.anonymous) {\n            topics.push(fragment.topicHash);\n        }\n        assertArgument(values.length === fragment.inputs.length, \"event arguments/values mismatch\", \"values\", values);\n        fragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this.#abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this.#abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(fragment, data, topics) {\n        if (typeof (fragment) === \"string\") {\n            const f = this.getEvent(fragment);\n            assertArgument(f, \"unknown event\", \"eventFragment\", fragment);\n            fragment = f;\n        }\n        if (topics != null && !fragment.anonymous) {\n            const eventTopic = fragment.topicHash;\n            assertArgument(isHexString(topics[0], 32) && topics[0].toLowerCase() === eventTopic, \"fragment/topic mismatch\", \"topics[0]\", topics[0]);\n            topics = topics.slice(1);\n        }\n        const indexed = [];\n        const nonIndexed = [];\n        const dynamic = [];\n        fragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.from({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        const resultIndexed = (topics != null) ? this.#abiCoder.decode(indexed, concat(topics)) : null;\n        const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data, true);\n        //const result: (Array<any> & { [ key: string ]: any }) = [ ];\n        const values = [];\n        const keys = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        fragment.inputs.forEach((param, index) => {\n            let value = null;\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    value = new Indexed(null);\n                }\n                else if (dynamic[index]) {\n                    value = new Indexed(resultIndexed[indexedIndex++]);\n                }\n                else {\n                    try {\n                        value = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        value = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    value = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    value = error;\n                }\n            }\n            values.push(value);\n            keys.push(param.name || null);\n        });\n        return Result.fromItems(values, keys);\n    }\n    /**\n     *  Parses a transaction, finding the matching function and extracts\n     *  the parameter values along with other useful function details.\n     *\n     *  If the matching function cannot be found, return null.\n     */\n    parseTransaction(tx) {\n        const data = getBytes(tx.data, \"tx.data\");\n        const value = getBigInt((tx.value != null) ? tx.value : 0, \"tx.value\");\n        const fragment = this.getFunction(hexlify(data.slice(0, 4)));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));\n        return new TransactionDescription(fragment, fragment.selector, args, value);\n    }\n    parseCallResult(data) {\n        throw new Error(\"@TODO\");\n    }\n    /**\n     *  Parses a receipt log, finding the matching event and extracts\n     *  the parameter values along with other useful event details.\n     *\n     *  If the matching event cannot be found, returns null.\n     */\n    parseLog(log) {\n        const fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));\n    }\n    /**\n     *  Parses a revert data, finding the matching error and extracts\n     *  the parameter values along with other useful error details.\n     *\n     *  If the matching error cannot be found, returns null.\n     */\n    parseError(data) {\n        const hexData = hexlify(data);\n        const fragment = this.getError(dataSlice(hexData, 0, 4));\n        if (!fragment) {\n            return null;\n        }\n        const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));\n        return new ErrorDescription(fragment, fragment.selector, args);\n    }\n    /**\n     *  Creates a new [[Interface]] from the ABI %%value%%.\n     *\n     *  The %%value%% may be provided as an existing [[Interface]] object,\n     *  a JSON-encoded ABI or any Human-Readable ABI format.\n     */\n    static from(value) {\n        // Already an Interface, which is immutable\n        if (value instanceof Interface) {\n            return value;\n        }\n        // JSON\n        if (typeof (value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        // An Interface; possibly from another v6 instance\n        if (typeof (value.formatJson) === \"function\") {\n            return new Interface(value.formatJson());\n        }\n        // A legacy Interface; from an older version\n        if (typeof (value.format) === \"function\") {\n            return new Interface(value.format(\"json\"));\n        }\n        // Array of fragments\n        return new Interface(value);\n    }\n}\n//# sourceMappingURL=interface.js.map","//import { resolveAddress } from \"@ethersproject/address\";\nimport { defineProperties, getBigInt, getNumber, hexlify, isBytesLike, resolveProperties, assert, assertArgument, isError, makeError } from \"../utils/index.js\";\nimport { accessListify } from \"../transaction/index.js\";\nconst BN_0 = BigInt(0);\n// -----------------------\nfunction getValue(value) {\n    if (value == null) {\n        return null;\n    }\n    return value;\n}\nfunction toJson(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.toString();\n}\n// @TODO? <T extends FeeData = { }> implements Required<T>\n/**\n *  A **FeeData** wraps all the fee-related values associated with\n *  the network.\n */\nexport class FeeData {\n    /**\n     *  The gas price for legacy networks.\n     */\n    gasPrice;\n    /**\n     *  The maximum fee to pay per gas.\n     *\n     *  The base fee per gas is defined by the network and based on\n     *  congestion, increasing the cost during times of heavy load\n     *  and lowering when less busy.\n     *\n     *  The actual fee per gas will be the base fee for the block\n     *  and the priority fee, up to the max fee per gas.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxFeePerGas;\n    /**\n     *  The additional amout to pay per gas to encourage a validator\n     *  to include the transaction.\n     *\n     *  The purpose of this is to compensate the validator for the\n     *  adjusted risk for including a given transaction.\n     *\n     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and\n     *  %%maxPriorityFeePerGas%%.\n     */\n    constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {\n        defineProperties(this, {\n            gasPrice: getValue(gasPrice),\n            maxFeePerGas: getValue(maxFeePerGas),\n            maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)\n        });\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;\n        return {\n            _type: \"FeeData\",\n            gasPrice: toJson(gasPrice),\n            maxFeePerGas: toJson(maxFeePerGas),\n            maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),\n        };\n    }\n}\n;\n/**\n *  Returns a copy of %%req%% with all properties coerced to their strict\n *  types.\n */\nexport function copyRequest(req) {\n    const result = {};\n    // These could be addresses, ENS names or Addressables\n    if (req.to) {\n        result.to = req.to;\n    }\n    if (req.from) {\n        result.from = req.from;\n    }\n    if (req.data) {\n        result.data = hexlify(req.data);\n    }\n    const bigIntKeys = \"chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value\".split(/,/);\n    for (const key of bigIntKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = getBigInt(req[key], `request.${key}`);\n    }\n    const numberKeys = \"type,nonce\".split(/,/);\n    for (const key of numberKeys) {\n        if (!(key in req) || req[key] == null) {\n            continue;\n        }\n        result[key] = getNumber(req[key], `request.${key}`);\n    }\n    if (req.accessList) {\n        result.accessList = accessListify(req.accessList);\n    }\n    if (\"blockTag\" in req) {\n        result.blockTag = req.blockTag;\n    }\n    if (\"enableCcipRead\" in req) {\n        result.enableCcipRead = !!req.enableCcipRead;\n    }\n    if (\"customData\" in req) {\n        result.customData = req.customData;\n    }\n    if (\"blobVersionedHashes\" in req && req.blobVersionedHashes) {\n        result.blobVersionedHashes = req.blobVersionedHashes.slice();\n    }\n    if (\"kzg\" in req) {\n        result.kzg = req.kzg;\n    }\n    if (\"blobs\" in req && req.blobs) {\n        result.blobs = req.blobs.map((b) => {\n            if (isBytesLike(b)) {\n                return hexlify(b);\n            }\n            return Object.assign({}, b);\n        });\n    }\n    return result;\n}\n/**\n *  A **Block** represents the data associated with a full block on\n *  Ethereum.\n */\nexport class Block {\n    /**\n     *  The provider connected to the block used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The block number, sometimes called the block height. This is a\n     *  sequential number that is one higher than the parent block.\n     */\n    number;\n    /**\n     *  The block hash.\n     *\n     *  This hash includes all properties, so can be safely used to identify\n     *  an exact set of block properties.\n     */\n    hash;\n    /**\n     *  The timestamp for this block, which is the number of seconds since\n     *  epoch that this block was included.\n     */\n    timestamp;\n    /**\n     *  The block hash of the parent block.\n     */\n    parentHash;\n    /**\n     *  The hash tree root of the parent beacon block for the given\n     *  execution block. See [[link-eip-4788]].\n     */\n    parentBeaconBlockRoot;\n    /**\n     *  The nonce.\n     *\n     *  On legacy networks, this is the random number inserted which\n     *  permitted the difficulty target to be reached.\n     */\n    nonce;\n    /**\n     *  The difficulty target.\n     *\n     *  On legacy networks, this is the proof-of-work target required\n     *  for a block to meet the protocol rules to be included.\n     *\n     *  On modern networks, this is a random number arrived at using\n     *  randao.  @TODO: Find links?\n     */\n    difficulty;\n    /**\n     *  The total gas limit for this block.\n     */\n    gasLimit;\n    /**\n     *  The total gas used in this block.\n     */\n    gasUsed;\n    /**\n     *  The root hash for the global state after applying changes\n     *  in this block.\n     */\n    stateRoot;\n    /**\n     *  The hash of the transaction receipts trie.\n     */\n    receiptsRoot;\n    /**\n     *  The total amount of blob gas consumed by the transactions\n     *  within the block. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The running total of blob gas consumed in excess of the\n     *  target, prior to the block. See [[link-eip-4844]].\n     */\n    excessBlobGas;\n    /**\n     *  The miner coinbase address, wihch receives any subsidies for\n     *  including this block.\n     */\n    miner;\n    /**\n     *  The latest RANDAO mix of the post beacon state of\n     *  the previous block.\n     */\n    prevRandao;\n    /**\n     *  Any extra data the validator wished to include.\n     */\n    extraData;\n    /**\n     *  The base fee per gas that all transactions in this block were\n     *  charged.\n     *\n     *  This adjusts after each block, depending on how congested the network\n     *  is.\n     */\n    baseFeePerGas;\n    #transactions;\n    /**\n     *  Create a new **Block** object.\n     *\n     *  This should generally not be necessary as the unless implementing a\n     *  low-level library.\n     */\n    constructor(block, provider) {\n        this.#transactions = block.transactions.map((tx) => {\n            if (typeof (tx) !== \"string\") {\n                return new TransactionResponse(tx, provider);\n            }\n            return tx;\n        });\n        defineProperties(this, {\n            provider,\n            hash: getValue(block.hash),\n            number: block.number,\n            timestamp: block.timestamp,\n            parentHash: block.parentHash,\n            parentBeaconBlockRoot: block.parentBeaconBlockRoot,\n            nonce: block.nonce,\n            difficulty: block.difficulty,\n            gasLimit: block.gasLimit,\n            gasUsed: block.gasUsed,\n            blobGasUsed: block.blobGasUsed,\n            excessBlobGas: block.excessBlobGas,\n            miner: block.miner,\n            prevRandao: getValue(block.prevRandao),\n            extraData: block.extraData,\n            baseFeePerGas: getValue(block.baseFeePerGas),\n            stateRoot: block.stateRoot,\n            receiptsRoot: block.receiptsRoot,\n        });\n    }\n    /**\n     *  Returns the list of transaction hashes, in the order\n     *  they were executed within the block.\n     */\n    get transactions() {\n        return this.#transactions.map((tx) => {\n            if (typeof (tx) === \"string\") {\n                return tx;\n            }\n            return tx.hash;\n        });\n    }\n    /**\n     *  Returns the complete transactions, in the order they\n     *  were executed within the block.\n     *\n     *  This is only available for blocks which prefetched\n     *  transactions, by passing ``true`` to %%prefetchTxs%%\n     *  into [[Provider-getBlock]].\n     */\n    get prefetchedTransactions() {\n        const txs = this.#transactions.slice();\n        // Doesn't matter...\n        if (txs.length === 0) {\n            return [];\n        }\n        // Make sure we prefetched the transactions\n        assert(typeof (txs[0]) === \"object\", \"transactions were not prefetched with block request\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"transactionResponses()\"\n        });\n        return txs;\n    }\n    /**\n     *  Returns a JSON-friendly value.\n     */\n    toJSON() {\n        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash, miner, prevRandao, nonce, number, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;\n        return {\n            _type: \"Block\",\n            baseFeePerGas: toJson(baseFeePerGas),\n            difficulty: toJson(difficulty),\n            extraData,\n            gasLimit: toJson(gasLimit),\n            gasUsed: toJson(gasUsed),\n            blobGasUsed: toJson(this.blobGasUsed),\n            excessBlobGas: toJson(this.excessBlobGas),\n            hash, miner, prevRandao, nonce, number, parentHash, timestamp,\n            parentBeaconBlockRoot, stateRoot, receiptsRoot,\n            transactions,\n        };\n    }\n    [Symbol.iterator]() {\n        let index = 0;\n        const txs = this.transactions;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return {\n                        value: txs[index++], done: false\n                    };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The number of transactions in this block.\n     */\n    get length() { return this.#transactions.length; }\n    /**\n     *  The [[link-js-date]] this block was included at.\n     */\n    get date() {\n        if (this.timestamp == null) {\n            return null;\n        }\n        return new Date(this.timestamp * 1000);\n    }\n    /**\n     *  Get the transaction at %%indexe%% within this block.\n     */\n    async getTransaction(indexOrHash) {\n        // Find the internal value by its index or hash\n        let tx = undefined;\n        if (typeof (indexOrHash) === \"number\") {\n            tx = this.#transactions[indexOrHash];\n        }\n        else {\n            const hash = indexOrHash.toLowerCase();\n            for (const v of this.#transactions) {\n                if (typeof (v) === \"string\") {\n                    if (v !== hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n                else {\n                    if (v.hash === hash) {\n                        continue;\n                    }\n                    tx = v;\n                    break;\n                }\n            }\n        }\n        if (tx == null) {\n            throw new Error(\"no such tx\");\n        }\n        if (typeof (tx) === \"string\") {\n            return (await this.provider.getTransaction(tx));\n        }\n        else {\n            return tx;\n        }\n    }\n    /**\n     *  If a **Block** was fetched with a request to include the transactions\n     *  this will allow synchronous access to those transactions.\n     *\n     *  If the transactions were not prefetched, this will throw.\n     */\n    getPrefetchedTransaction(indexOrHash) {\n        const txs = this.prefetchedTransactions;\n        if (typeof (indexOrHash) === \"number\") {\n            return txs[indexOrHash];\n        }\n        indexOrHash = indexOrHash.toLowerCase();\n        for (const tx of txs) {\n            if (tx.hash === indexOrHash) {\n                return tx;\n            }\n        }\n        assertArgument(false, \"no matching transaction\", \"indexOrHash\", indexOrHash);\n    }\n    /**\n     *  Returns true if this block been mined. This provides a type guard\n     *  for all properties on a [[MinedBlock]].\n     */\n    isMined() { return !!this.hash; }\n    /**\n     *  Returns true if this block is an [[link-eip-2930]] block.\n     */\n    isLondon() {\n        return !!this.baseFeePerGas;\n    }\n    /**\n     *  @_ignore:\n     */\n    orphanedEvent() {\n        if (!this.isMined()) {\n            throw new Error(\"\");\n        }\n        return createOrphanedBlockFilter(this);\n    }\n}\n//////////////////////\n// Log\n/**\n *  A **Log** in Ethereum represents an event that has been included in a\n *  transaction using the ``LOG*`` opcodes, which are most commonly used by\n *  Solidity's emit for announcing events.\n */\nexport class Log {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The transaction hash of the transaction this log occurred in. Use the\n     *  [[Log-getTransaction]] to get the [[TransactionResponse]].\n     */\n    transactionHash;\n    /**\n     *  The block hash of the block this log occurred in. Use the\n     *  [[Log-getBlock]] to get the [[Block]].\n     */\n    blockHash;\n    /**\n     *  The block number of the block this log occurred in. It is preferred\n     *  to use the [[Block-hash]] when fetching the related [[Block]],\n     *  since in the case of an orphaned block, the block at that height may\n     *  have changed.\n     */\n    blockNumber;\n    /**\n     *  If the **Log** represents a block that was removed due to an orphaned\n     *  block, this will be true.\n     *\n     *  This can only happen within an orphan event listener.\n     */\n    removed;\n    /**\n     *  The address of the contract that emitted this log.\n     */\n    address;\n    /**\n     *  The data included in this log when it was emitted.\n     */\n    data;\n    /**\n     *  The indexed topics included in this log when it was emitted.\n     *\n     *  All topics are included in the bloom filters, so they can be\n     *  efficiently filtered using the [[Provider-getLogs]] method.\n     */\n    topics;\n    /**\n     *  The index within the block this log occurred at. This is generally\n     *  not useful to developers, but can be used with the various roots\n     *  to proof inclusion within a block.\n     */\n    index;\n    /**\n     *  The index within the transaction of this log.\n     */\n    transactionIndex;\n    /**\n     *  @_ignore:\n     */\n    constructor(log, provider) {\n        this.provider = provider;\n        const topics = Object.freeze(log.topics.slice());\n        defineProperties(this, {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            removed: log.removed,\n            address: log.address,\n            data: log.data,\n            topics,\n            index: log.index,\n            transactionIndex: log.transactionIndex,\n        });\n    }\n    /**\n     *  Returns a JSON-compatible object.\n     */\n    toJSON() {\n        const { address, blockHash, blockNumber, data, index, removed, topics, transactionHash, transactionIndex } = this;\n        return {\n            _type: \"log\",\n            address, blockHash, blockNumber, data, index,\n            removed, topics, transactionHash, transactionIndex\n        };\n    }\n    /**\n     *  Returns the block that this log occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        assert(!!block, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return block;\n    }\n    /**\n     *  Returns the transaction that this log occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.transactionHash);\n        assert(!!tx, \"failed to find transaction\", \"UNKNOWN_ERROR\", {});\n        return tx;\n    }\n    /**\n     *  Returns the transaction receipt fot the transaction that this\n     *  log occurred in.\n     */\n    async getTransactionReceipt() {\n        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);\n        assert(!!receipt, \"failed to find transaction receipt\", \"UNKNOWN_ERROR\", {});\n        return receipt;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedLogFilter(this);\n    }\n}\n//////////////////////\n// Transaction Receipt\n/*\nexport interface LegacyTransactionReceipt {\n    byzantium: false;\n    status: null;\n    root: string;\n}\n\nexport interface ByzantiumTransactionReceipt {\n    byzantium: true;\n    status: number;\n    root: null;\n}\n*/\n/**\n *  A **TransactionReceipt** includes additional information about a\n *  transaction that is only available after it has been mined.\n */\nexport class TransactionReceipt {\n    /**\n     *  The provider connected to the log used to fetch additional details\n     *  if necessary.\n     */\n    provider;\n    /**\n     *  The address the transaction was sent to.\n     */\n    to;\n    /**\n     *  The sender of the transaction.\n     */\n    from;\n    /**\n     *  The address of the contract if the transaction was directly\n     *  responsible for deploying one.\n     *\n     *  This is non-null **only** if the ``to`` is empty and the ``data``\n     *  was successfully executed as initcode.\n     */\n    contractAddress;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The index of this transaction within the block transactions.\n     */\n    index;\n    /**\n     *  The block hash of the [[Block]] this transaction was included in.\n     */\n    blockHash;\n    /**\n     *  The block number of the [[Block]] this transaction was included in.\n     */\n    blockNumber;\n    /**\n     *  The bloom filter bytes that represent all logs that occurred within\n     *  this transaction. This is generally not useful for most developers,\n     *  but can be used to validate the included logs.\n     */\n    logsBloom;\n    /**\n     *  The actual amount of gas used by this transaction.\n     *\n     *  When creating a transaction, the amount of gas that will be used can\n     *  only be approximated, but the sender must pay the gas fee for the\n     *  entire gas limit. After the transaction, the difference is refunded.\n     */\n    gasUsed;\n    /**\n     *  The gas used for BLObs. See [[link-eip-4844]].\n     */\n    blobGasUsed;\n    /**\n     *  The amount of gas used by all transactions within the block for this\n     *  and all transactions with a lower ``index``.\n     *\n     *  This is generally not useful for developers but can be used to\n     *  validate certain aspects of execution.\n     */\n    cumulativeGasUsed;\n    /**\n     *  The actual gas price used during execution.\n     *\n     *  Due to the complexity of [[link-eip-1559]] this value can only\n     *  be caluclated after the transaction has been mined, snce the base\n     *  fee is protocol-enforced.\n     */\n    gasPrice;\n    /**\n     *  The price paid per BLOB in gas. See [[link-eip-4844]].\n     */\n    blobGasPrice;\n    /**\n     *  The [[link-eip-2718]] transaction type.\n     */\n    type;\n    //readonly byzantium!: boolean;\n    /**\n     *  The status of this transaction, indicating success (i.e. ``1``) or\n     *  a revert (i.e. ``0``).\n     *\n     *  This is available in post-byzantium blocks, but some backends may\n     *  backfill this value.\n     */\n    status;\n    /**\n     *  The root hash of this transaction.\n     *\n     *  This is no present and was only included in pre-byzantium blocks, but\n     *  could be used to validate certain parts of the receipt.\n     */\n    root;\n    #logs;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.#logs = Object.freeze(tx.logs.map((log) => {\n            return new Log(log, provider);\n        }));\n        let gasPrice = BN_0;\n        if (tx.effectiveGasPrice != null) {\n            gasPrice = tx.effectiveGasPrice;\n        }\n        else if (tx.gasPrice != null) {\n            gasPrice = tx.gasPrice;\n        }\n        defineProperties(this, {\n            provider,\n            to: tx.to,\n            from: tx.from,\n            contractAddress: tx.contractAddress,\n            hash: tx.hash,\n            index: tx.index,\n            blockHash: tx.blockHash,\n            blockNumber: tx.blockNumber,\n            logsBloom: tx.logsBloom,\n            gasUsed: tx.gasUsed,\n            cumulativeGasUsed: tx.cumulativeGasUsed,\n            blobGasUsed: tx.blobGasUsed,\n            gasPrice,\n            blobGasPrice: tx.blobGasPrice,\n            type: tx.type,\n            //byzantium: tx.byzantium,\n            status: tx.status,\n            root: tx.root\n        });\n    }\n    /**\n     *  The logs for this transaction.\n     */\n    get logs() { return this.#logs; }\n    /**\n     *  Returns a JSON-compatible representation.\n     */\n    toJSON() {\n        const { to, from, contractAddress, hash, index, blockHash, blockNumber, logsBloom, logs, //byzantium, \n        status, root } = this;\n        return {\n            _type: \"TransactionReceipt\",\n            blockHash, blockNumber,\n            //byzantium, \n            contractAddress,\n            cumulativeGasUsed: toJson(this.cumulativeGasUsed),\n            from,\n            gasPrice: toJson(this.gasPrice),\n            blobGasUsed: toJson(this.blobGasUsed),\n            blobGasPrice: toJson(this.blobGasPrice),\n            gasUsed: toJson(this.gasUsed),\n            hash, index, logs, logsBloom, root, status, to\n        };\n    }\n    /**\n     *  @_ignore:\n     */\n    get length() { return this.logs.length; }\n    [Symbol.iterator]() {\n        let index = 0;\n        return {\n            next: () => {\n                if (index < this.length) {\n                    return { value: this.logs[index++], done: false };\n                }\n                return { value: undefined, done: true };\n            }\n        };\n    }\n    /**\n     *  The total fee for this transaction, in wei.\n     */\n    get fee() {\n        return this.gasUsed * this.gasPrice;\n    }\n    /**\n     *  Resolves to the block this transaction occurred in.\n     */\n    async getBlock() {\n        const block = await this.provider.getBlock(this.blockHash);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to the transaction this transaction occurred in.\n     */\n    async getTransaction() {\n        const tx = await this.provider.getTransaction(this.hash);\n        if (tx == null) {\n            throw new Error(\"TODO\");\n        }\n        return tx;\n    }\n    /**\n     *  Resolves to the return value of the execution of this transaction.\n     *\n     *  Support for this feature is limited, as it requires an archive node\n     *  with the ``debug_`` or ``trace_`` API enabled.\n     */\n    async getResult() {\n        return (await this.provider.getTransactionResult(this.hash));\n    }\n    /**\n     *  Resolves to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        return (await this.provider.getBlockNumber()) - this.blockNumber + 1;\n    }\n    /**\n     *  @_ignore:\n     */\n    removedEvent() {\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  @_ignore:\n     */\n    reorderedEvent(other) {\n        assert(!other || other.isMined(), \"unmined 'other' transction cannot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"reorderedEvent(other)\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n}\n/**\n *  A **TransactionResponse** includes all properties about a transaction\n *  that was sent to the network, which may or may not be included in a\n *  block.\n *\n *  The [[TransactionResponse-isMined]] can be used to check if the\n *  transaction has been mined as well as type guard that the otherwise\n *  possibly ``null`` properties are defined.\n */\nexport class TransactionResponse {\n    /**\n     *  The provider this is connected to, which will influence how its\n     *  methods will resolve its async inspection methods.\n     */\n    provider;\n    /**\n     *  The block number of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockNumber;\n    /**\n     *  The blockHash of the block that this transaction was included in.\n     *\n     *  This is ``null`` for pending transactions.\n     */\n    blockHash;\n    /**\n     *  The index within the block that this transaction resides at.\n     */\n    index;\n    /**\n     *  The transaction hash.\n     */\n    hash;\n    /**\n     *  The [[link-eip-2718]] transaction envelope type. This is\n     *  ``0`` for legacy transactions types.\n     */\n    type;\n    /**\n     *  The receiver of this transaction.\n     *\n     *  If ``null``, then the transaction is an initcode transaction.\n     *  This means the result of executing the [[data]] will be deployed\n     *  as a new contract on chain (assuming it does not revert) and the\n     *  address may be computed using [[getCreateAddress]].\n     */\n    to;\n    /**\n     *  The sender of this transaction. It is implicitly computed\n     *  from the transaction pre-image hash (as the digest) and the\n     *  [[signature]] using ecrecover.\n     */\n    from;\n    /**\n     *  The nonce, which is used to prevent replay attacks and offer\n     *  a method to ensure transactions from a given sender are explicitly\n     *  ordered.\n     *\n     *  When sending a transaction, this must be equal to the number of\n     *  transactions ever sent by [[from]].\n     */\n    nonce;\n    /**\n     *  The maximum units of gas this transaction can consume. If execution\n     *  exceeds this, the entries transaction is reverted and the sender\n     *  is charged for the full amount, despite not state changes being made.\n     */\n    gasLimit;\n    /**\n     *  The gas price can have various values, depending on the network.\n     *\n     *  In modern networks, for transactions that are included this is\n     *  the //effective gas price// (the fee per gas that was actually\n     *  charged), while for transactions that have not been included yet\n     *  is the [[maxFeePerGas]].\n     *\n     *  For legacy transactions, or transactions on legacy networks, this\n     *  is the fee that will be charged per unit of gas the transaction\n     *  consumes.\n     */\n    gasPrice;\n    /**\n     *  The maximum priority fee (per unit of gas) to allow a\n     *  validator to charge the sender. This is inclusive of the\n     *  [[maxFeeFeePerGas]].\n     */\n    maxPriorityFeePerGas;\n    /**\n     *  The maximum fee (per unit of gas) to allow this transaction\n     *  to charge the sender.\n     */\n    maxFeePerGas;\n    /**\n     *  The [[link-eip-4844]] max fee per BLOb gas.\n     */\n    maxFeePerBlobGas;\n    /**\n     *  The data.\n     */\n    data;\n    /**\n     *  The value, in wei. Use [[formatEther]] to format this value\n     *  as ether.\n     */\n    value;\n    /**\n     *  The chain ID.\n     */\n    chainId;\n    /**\n     *  The signature.\n     */\n    signature;\n    /**\n     *  The [[link-eip-2930]] access list for transaction types that\n     *  support it, otherwise ``null``.\n     */\n    accessList;\n    /**\n     *  The [[link-eip-4844]] BLOb versioned hashes.\n     */\n    blobVersionedHashes;\n    #startBlock;\n    /**\n     *  @_ignore:\n     */\n    constructor(tx, provider) {\n        this.provider = provider;\n        this.blockNumber = (tx.blockNumber != null) ? tx.blockNumber : null;\n        this.blockHash = (tx.blockHash != null) ? tx.blockHash : null;\n        this.hash = tx.hash;\n        this.index = tx.index;\n        this.type = tx.type;\n        this.from = tx.from;\n        this.to = tx.to || null;\n        this.gasLimit = tx.gasLimit;\n        this.nonce = tx.nonce;\n        this.data = tx.data;\n        this.value = tx.value;\n        this.gasPrice = tx.gasPrice;\n        this.maxPriorityFeePerGas = (tx.maxPriorityFeePerGas != null) ? tx.maxPriorityFeePerGas : null;\n        this.maxFeePerGas = (tx.maxFeePerGas != null) ? tx.maxFeePerGas : null;\n        this.maxFeePerBlobGas = (tx.maxFeePerBlobGas != null) ? tx.maxFeePerBlobGas : null;\n        this.chainId = tx.chainId;\n        this.signature = tx.signature;\n        this.accessList = (tx.accessList != null) ? tx.accessList : null;\n        this.blobVersionedHashes = (tx.blobVersionedHashes != null) ? tx.blobVersionedHashes : null;\n        this.#startBlock = -1;\n    }\n    /**\n     *  Returns a JSON-compatible representation of this transaction.\n     */\n    toJSON() {\n        const { blockNumber, blockHash, index, hash, type, to, from, nonce, data, signature, accessList, blobVersionedHashes } = this;\n        return {\n            _type: \"TransactionResponse\",\n            accessList, blockNumber, blockHash,\n            blobVersionedHashes,\n            chainId: toJson(this.chainId),\n            data, from,\n            gasLimit: toJson(this.gasLimit),\n            gasPrice: toJson(this.gasPrice),\n            hash,\n            maxFeePerGas: toJson(this.maxFeePerGas),\n            maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),\n            maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),\n            nonce, signature, to, index, type,\n            value: toJson(this.value),\n        };\n    }\n    /**\n     *  Resolves to the Block that this transaction was included in.\n     *\n     *  This will return null if the transaction has not been included yet.\n     */\n    async getBlock() {\n        let blockNumber = this.blockNumber;\n        if (blockNumber == null) {\n            const tx = await this.getTransaction();\n            if (tx) {\n                blockNumber = tx.blockNumber;\n            }\n        }\n        if (blockNumber == null) {\n            return null;\n        }\n        const block = this.provider.getBlock(blockNumber);\n        if (block == null) {\n            throw new Error(\"TODO\");\n        }\n        return block;\n    }\n    /**\n     *  Resolves to this transaction being re-requested from the\n     *  provider. This can be used if you have an unmined transaction\n     *  and wish to get an up-to-date populated instance.\n     */\n    async getTransaction() {\n        return this.provider.getTransaction(this.hash);\n    }\n    /**\n     *  Resolve to the number of confirmations this transaction has.\n     */\n    async confirmations() {\n        if (this.blockNumber == null) {\n            const { tx, blockNumber } = await resolveProperties({\n                tx: this.getTransaction(),\n                blockNumber: this.provider.getBlockNumber()\n            });\n            // Not mined yet...\n            if (tx == null || tx.blockNumber == null) {\n                return 0;\n            }\n            return blockNumber - tx.blockNumber + 1;\n        }\n        const blockNumber = await this.provider.getBlockNumber();\n        return blockNumber - this.blockNumber + 1;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(_confirms, _timeout) {\n        const confirms = (_confirms == null) ? 1 : _confirms;\n        const timeout = (_timeout == null) ? 0 : _timeout;\n        let startBlock = this.#startBlock;\n        let nextScan = -1;\n        let stopScanning = (startBlock === -1) ? true : false;\n        const checkReplacement = async () => {\n            // Get the current transaction count for this sender\n            if (stopScanning) {\n                return null;\n            }\n            const { blockNumber, nonce } = await resolveProperties({\n                blockNumber: this.provider.getBlockNumber(),\n                nonce: this.provider.getTransactionCount(this.from)\n            });\n            // No transaction or our nonce has not been mined yet; but we\n            // can start scanning later when we do start\n            if (nonce < this.nonce) {\n                startBlock = blockNumber;\n                return;\n            }\n            // We were mined; no replacement\n            if (stopScanning) {\n                return null;\n            }\n            const mined = await this.getTransaction();\n            if (mined && mined.blockNumber != null) {\n                return;\n            }\n            // We were replaced; start scanning for that transaction\n            // Starting to scan; look back a few extra blocks for safety\n            if (nextScan === -1) {\n                nextScan = startBlock - 3;\n                if (nextScan < this.#startBlock) {\n                    nextScan = this.#startBlock;\n                }\n            }\n            while (nextScan <= blockNumber) {\n                // Get the next block to scan\n                if (stopScanning) {\n                    return null;\n                }\n                const block = await this.provider.getBlock(nextScan, true);\n                // This should not happen; but we'll try again shortly\n                if (block == null) {\n                    return;\n                }\n                // We were mined; no replacement\n                for (const hash of block) {\n                    if (hash === this.hash) {\n                        return;\n                    }\n                }\n                // Search for the transaction that replaced us\n                for (let i = 0; i < block.length; i++) {\n                    const tx = await block.getTransaction(i);\n                    if (tx.from === this.from && tx.nonce === this.nonce) {\n                        // Get the receipt\n                        if (stopScanning) {\n                            return null;\n                        }\n                        const receipt = await this.provider.getTransactionReceipt(tx.hash);\n                        // This should not happen; but we'll try again shortly\n                        if (receipt == null) {\n                            return;\n                        }\n                        // We will retry this on the next block (this case could be optimized)\n                        if ((blockNumber - receipt.blockNumber + 1) < confirms) {\n                            return;\n                        }\n                        // The reason we were replaced\n                        let reason = \"replaced\";\n                        if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {\n                            reason = \"repriced\";\n                        }\n                        else if (tx.data === \"0x\" && tx.from === tx.to && tx.value === BN_0) {\n                            reason = \"cancelled\";\n                        }\n                        assert(false, \"transaction was replaced\", \"TRANSACTION_REPLACED\", {\n                            cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                            reason,\n                            replacement: tx.replaceableTransaction(startBlock),\n                            hash: tx.hash,\n                            receipt\n                        });\n                    }\n                }\n                nextScan++;\n            }\n            return;\n        };\n        const checkReceipt = (receipt) => {\n            if (receipt == null || receipt.status !== 0) {\n                return receipt;\n            }\n            assert(false, \"transaction execution reverted\", \"CALL_EXCEPTION\", {\n                action: \"sendTransaction\",\n                data: null, reason: null, invocation: null, revert: null,\n                transaction: {\n                    to: receipt.to,\n                    from: receipt.from,\n                    data: \"\" // @TODO: in v7, split out sendTransaction properties\n                }, receipt\n            });\n        };\n        const receipt = await this.provider.getTransactionReceipt(this.hash);\n        if (confirms === 0) {\n            return checkReceipt(receipt);\n        }\n        if (receipt) {\n            if ((await receipt.confirmations()) >= confirms) {\n                return checkReceipt(receipt);\n            }\n        }\n        else {\n            // Check for a replacement; throws if a replacement was found\n            await checkReplacement();\n            // Allow null only when the confirms is 0\n            if (confirms === 0) {\n                return null;\n            }\n        }\n        const waiter = new Promise((resolve, reject) => {\n            // List of things to cancel when we have a result (one way or the other)\n            const cancellers = [];\n            const cancel = () => { cancellers.forEach((c) => c()); };\n            // On cancel, stop scanning for replacements\n            cancellers.push(() => { stopScanning = true; });\n            // Set up any timeout requested\n            if (timeout > 0) {\n                const timer = setTimeout(() => {\n                    cancel();\n                    reject(makeError(\"wait for transaction timeout\", \"TIMEOUT\"));\n                }, timeout);\n                cancellers.push(() => { clearTimeout(timer); });\n            }\n            const txListener = async (receipt) => {\n                // Done; return it!\n                if ((await receipt.confirmations()) >= confirms) {\n                    cancel();\n                    try {\n                        resolve(checkReceipt(receipt));\n                    }\n                    catch (error) {\n                        reject(error);\n                    }\n                }\n            };\n            cancellers.push(() => { this.provider.off(this.hash, txListener); });\n            this.provider.on(this.hash, txListener);\n            // We support replacement detection; start checking\n            if (startBlock >= 0) {\n                const replaceListener = async () => {\n                    try {\n                        // Check for a replacement; this throws only if one is found\n                        await checkReplacement();\n                    }\n                    catch (error) {\n                        // We were replaced (with enough confirms); re-throw the error\n                        if (isError(error, \"TRANSACTION_REPLACED\")) {\n                            cancel();\n                            reject(error);\n                            return;\n                        }\n                    }\n                    // Rescheudle a check on the next block\n                    if (!stopScanning) {\n                        this.provider.once(\"block\", replaceListener);\n                    }\n                };\n                cancellers.push(() => { this.provider.off(\"block\", replaceListener); });\n                this.provider.once(\"block\", replaceListener);\n            }\n        });\n        return await waiter;\n    }\n    /**\n     *  Returns ``true`` if this transaction has been included.\n     *\n     *  This is effective only as of the time the TransactionResponse\n     *  was instantiated. To get up-to-date information, use\n     *  [[getTransaction]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  non-null property values for properties that are null for\n     *  unmined transactions.\n     */\n    isMined() {\n        return (this.blockHash != null);\n    }\n    /**\n     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)\n     *  transaction.\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLegacy() {\n        return (this.type === 0);\n    }\n    /**\n     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)\n     *  transaction. See [[link-eip-2070]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isBerlin() {\n        return (this.type === 1);\n    }\n    /**\n     *  Returns true if the transaction is a London (i.e. ``type == 2``)\n     *  transaction. See [[link-eip-1559]].\n     *\n     *  This provides a Type Guard that this transaction will have\n     *  the ``null``-ness for hardfork-specific properties set correctly.\n     */\n    isLondon() {\n        return (this.type === 2);\n    }\n    /**\n     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)\n     *  transaction. See [[link-eip-4844]].\n     */\n    isCancun() {\n        return (this.type === 3);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that evict this transaction.\n     */\n    removedEvent() {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createRemovedTransactionFilter(this);\n    }\n    /**\n     *  Returns a filter which can be used to listen for orphan events\n     *  that re-order this event against %%other%%.\n     */\n    reorderedEvent(other) {\n        assert(this.isMined(), \"unmined transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        assert(!other || other.isMined(), \"unmined 'other' transaction canot be orphaned\", \"UNSUPPORTED_OPERATION\", { operation: \"removeEvent()\" });\n        return createReorderedTransactionFilter(this, other);\n    }\n    /**\n     *  Returns a new TransactionResponse instance which has the ability to\n     *  detect (and throw an error) if the transaction is replaced, which\n     *  will begin scanning at %%startBlock%%.\n     *\n     *  This should generally not be used by developers and is intended\n     *  primarily for internal use. Setting an incorrect %%startBlock%% can\n     *  have devastating performance consequences if used incorrectly.\n     */\n    replaceableTransaction(startBlock) {\n        assertArgument(Number.isInteger(startBlock) && startBlock >= 0, \"invalid startBlock\", \"startBlock\", startBlock);\n        const tx = new TransactionResponse(this, this.provider);\n        tx.#startBlock = startBlock;\n        return tx;\n    }\n}\nfunction createOrphanedBlockFilter(block) {\n    return { orphan: \"drop-block\", hash: block.hash, number: block.number };\n}\nfunction createReorderedTransactionFilter(tx, other) {\n    return { orphan: \"reorder-transaction\", tx, other };\n}\nfunction createRemovedTransactionFilter(tx) {\n    return { orphan: \"drop-transaction\", tx };\n}\nfunction createRemovedLogFilter(log) {\n    return { orphan: \"drop-log\", log: {\n            transactionHash: log.transactionHash,\n            blockHash: log.blockHash,\n            blockNumber: log.blockNumber,\n            address: log.address,\n            data: log.data,\n            topics: Object.freeze(log.topics.slice()),\n            index: log.index\n        } };\n}\n//# sourceMappingURL=provider.js.map","// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { Log, TransactionReceipt, TransactionResponse } from \"../providers/provider.js\";\nimport { defineProperties, EventPayload } from \"../utils/index.js\";\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class EventLog extends Log {\n    /**\n     *  The Contract Interface.\n     */\n    interface;\n    /**\n     *  The matching event.\n     */\n    fragment;\n    /**\n     *  The parsed arguments passed to the event by ``emit``.\n     */\n    args;\n    /**\n     * @_ignore:\n     */\n    constructor(log, iface, fragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        defineProperties(this, { args, fragment, interface: iface });\n    }\n    /**\n     *  The name of the event.\n     */\n    get eventName() { return this.fragment.name; }\n    /**\n     *  The signature of the event.\n     */\n    get eventSignature() { return this.fragment.format(); }\n}\n/**\n *  An **EventLog** contains additional properties parsed from the [[Log]].\n */\nexport class UndecodedEventLog extends Log {\n    /**\n     *  The error encounted when trying to decode the log.\n     */\n    error;\n    /**\n     * @_ignore:\n     */\n    constructor(log, error) {\n        super(log, log.provider);\n        defineProperties(this, { error });\n    }\n}\n/**\n *  A **ContractTransactionReceipt** includes the parsed logs from a\n *  [[TransactionReceipt]].\n */\nexport class ContractTransactionReceipt extends TransactionReceipt {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  The parsed logs for any [[Log]] which has a matching event in the\n     *  Contract ABI.\n     */\n    get logs() {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;\n            if (fragment) {\n                try {\n                    return new EventLog(log, this.#iface, fragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return log;\n        });\n    }\n}\n/**\n *  A **ContractTransactionResponse** will return a\n *  [[ContractTransactionReceipt]] when waited on.\n */\nexport class ContractTransactionResponse extends TransactionResponse {\n    #iface;\n    /**\n     *  @_ignore:\n     */\n    constructor(iface, provider, tx) {\n        super(tx, provider);\n        this.#iface = iface;\n    }\n    /**\n     *  Resolves once this transaction has been mined and has\n     *  %%confirms%% blocks including it (default: ``1``) with an\n     *  optional %%timeout%%.\n     *\n     *  This can resolve to ``null`` only if %%confirms%% is ``0``\n     *  and the transaction has not been mined, otherwise this will\n     *  wait until enough confirmations have completed.\n     */\n    async wait(confirms, timeout) {\n        const receipt = await super.wait(confirms, timeout);\n        if (receipt == null) {\n            return null;\n        }\n        return new ContractTransactionReceipt(this.#iface, this.provider, receipt);\n    }\n}\n/**\n *  A **ContractUnknownEventPayload** is included as the last parameter to\n *  Contract Events when the event does not match any events in the ABI.\n */\nexport class ContractUnknownEventPayload extends EventPayload {\n    /**\n     *  The log with no matching events.\n     */\n    log;\n    /**\n     *  @_event:\n     */\n    constructor(contract, listener, filter, log) {\n        super(contract, listener, filter);\n        defineProperties(this, { log });\n    }\n    /**\n     *  Resolves to the block the event occured in.\n     */\n    async getBlock() {\n        return await this.log.getBlock();\n    }\n    /**\n     *  Resolves to the transaction the event occured in.\n     */\n    async getTransaction() {\n        return await this.log.getTransaction();\n    }\n    /**\n     *  Resolves to the transaction receipt the event occured in.\n     */\n    async getTransactionReceipt() {\n        return await this.log.getTransactionReceipt();\n    }\n}\n/**\n *  A **ContractEventPayload** is included as the last parameter to\n *  Contract Events when the event is known.\n */\nexport class ContractEventPayload extends ContractUnknownEventPayload {\n    /**\n     *  @_ignore:\n     */\n    constructor(contract, listener, filter, fragment, _log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        defineProperties(this, { args, fragment });\n    }\n    /**\n     *  The event name.\n     */\n    get eventName() {\n        return this.fragment.name;\n    }\n    /**\n     *  The event signature.\n     */\n    get eventSignature() {\n        return this.fragment.format();\n    }\n}\n//# sourceMappingURL=wrappers.js.map","import { Interface, Typed } from \"../abi/index.js\";\nimport { isAddressable, resolveAddress } from \"../address/index.js\";\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport { copyRequest, Log } from \"../providers/provider.js\";\nimport { defineProperties, getBigInt, isCallException, isHexString, resolveProperties, isError, makeError, assert, assertArgument } from \"../utils/index.js\";\nimport { ContractEventPayload, ContractUnknownEventPayload, ContractTransactionResponse, EventLog, UndecodedEventLog } from \"./wrappers.js\";\nconst BN_0 = BigInt(0);\nfunction canCall(value) {\n    return (value && typeof (value.call) === \"function\");\n}\nfunction canEstimate(value) {\n    return (value && typeof (value.estimateGas) === \"function\");\n}\nfunction canResolve(value) {\n    return (value && typeof (value.resolveName) === \"function\");\n}\nfunction canSend(value) {\n    return (value && typeof (value.sendTransaction) === \"function\");\n}\nfunction getResolver(value) {\n    if (value != null) {\n        if (canResolve(value)) {\n            return value;\n        }\n        if (value.provider) {\n            return value.provider;\n        }\n    }\n    return undefined;\n}\nclass PreparedTopicFilter {\n    #filter;\n    fragment;\n    constructor(contract, fragment, args) {\n        defineProperties(this, { fragment });\n        if (fragment.inputs.length < args.length) {\n            throw new Error(\"too many arguments\");\n        }\n        // Recursively descend into args and resolve any addresses\n        const runner = getRunner(contract.runner, \"resolveName\");\n        const resolver = canResolve(runner) ? runner : null;\n        this.#filter = (async function () {\n            const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {\n                const arg = args[index];\n                if (arg == null) {\n                    return null;\n                }\n                return param.walkAsync(args[index], (type, value) => {\n                    if (type === \"address\") {\n                        if (Array.isArray(value)) {\n                            return Promise.all(value.map((v) => resolveAddress(v, resolver)));\n                        }\n                        return resolveAddress(value, resolver);\n                    }\n                    return value;\n                });\n            }));\n            return contract.interface.encodeFilterTopics(fragment, resolvedArgs);\n        })();\n    }\n    getTopicFilter() {\n        return this.#filter;\n    }\n}\n// A = Arguments passed in as a tuple\n// R = The result type of the call (i.e. if only one return type,\n//     the qualified type, otherwise Result)\n// D = The type the default call will return (i.e. R for view/pure,\n//     TransactionResponse otherwise)\n//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {\nfunction getRunner(value, feature) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value[feature]) === \"function\") {\n        return value;\n    }\n    if (value.provider && typeof (value.provider[feature]) === \"function\") {\n        return value.provider;\n    }\n    return null;\n}\nfunction getProvider(value) {\n    if (value == null) {\n        return null;\n    }\n    return value.provider || null;\n}\n/**\n *  @_ignore:\n */\nexport async function copyOverrides(arg, allowed) {\n    // Make sure the overrides passed in are a valid overrides object\n    const _overrides = Typed.dereference(arg, \"overrides\");\n    assertArgument(typeof (_overrides) === \"object\", \"invalid overrides parameter\", \"overrides\", arg);\n    // Create a shallow copy (we'll deep-ify anything needed during normalizing)\n    const overrides = copyRequest(_overrides);\n    assertArgument(overrides.to == null || (allowed || []).indexOf(\"to\") >= 0, \"cannot override to\", \"overrides.to\", overrides.to);\n    assertArgument(overrides.data == null || (allowed || []).indexOf(\"data\") >= 0, \"cannot override data\", \"overrides.data\", overrides.data);\n    // Resolve any from\n    if (overrides.from) {\n        overrides.from = overrides.from;\n    }\n    return overrides;\n}\n/**\n *  @_ignore:\n */\nexport async function resolveArgs(_runner, inputs, args) {\n    // Recursively descend into args and resolve any addresses\n    const runner = getRunner(_runner, \"resolveName\");\n    const resolver = canResolve(runner) ? runner : null;\n    return await Promise.all(inputs.map((param, index) => {\n        return param.walkAsync(args[index], (type, value) => {\n            value = Typed.dereference(value, type);\n            if (type === \"address\") {\n                return resolveAddress(value, resolver);\n            }\n            return value;\n        });\n    }));\n}\nfunction buildWrappedFallback(contract) {\n    const populateTransaction = async function (overrides) {\n        // If an overrides was passed in, copy it and normalize the values\n        const tx = (await copyOverrides(overrides, [\"data\"]));\n        tx.to = await contract.getAddress();\n        if (tx.from) {\n            tx.from = await resolveAddress(tx.from, getResolver(contract.runner));\n        }\n        const iface = contract.interface;\n        const noValue = (getBigInt((tx.value || BN_0), \"overrides.value\") === BN_0);\n        const noData = ((tx.data || \"0x\") === \"0x\");\n        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {\n            assertArgument(false, \"cannot send data to receive or send value to non-payable fallback\", \"overrides\", overrides);\n        }\n        assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        // Only allow payable contracts to set non-zero value\n        const payable = iface.receive || (iface.fallback && iface.fallback.payable);\n        assertArgument(payable || noValue, \"cannot send value to non-payable fallback\", \"overrides.value\", tx.value);\n        // Only allow fallback contracts to set non-empty data\n        assertArgument(iface.fallback || noData, \"cannot send data to receive-only contract\", \"overrides.data\", tx.data);\n        return tx;\n    };\n    const staticCall = async function (overrides) {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(overrides);\n        try {\n            return await runner.call(tx);\n        }\n        catch (error) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n    };\n    const send = async function (overrides) {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(overrides));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (overrides) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(overrides));\n    };\n    const method = async (overrides) => {\n        return await send(overrides);\n    };\n    defineProperties(method, {\n        _contract: contract,\n        estimateGas,\n        populateTransaction,\n        send, staticCall\n    });\n    return method;\n}\nfunction buildWrappedMethod(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getFunction(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const populateTransaction = async function (...args) {\n        const fragment = getFragment(...args);\n        // If an overrides was passed in, copy it and normalize the values\n        let overrides = {};\n        if (fragment.inputs.length + 1 === args.length) {\n            overrides = await copyOverrides(args.pop());\n            if (overrides.from) {\n                overrides.from = await resolveAddress(overrides.from, getResolver(contract.runner));\n            }\n        }\n        if (fragment.inputs.length !== args.length) {\n            throw new Error(\"internal error: fragment inputs doesn't match arguments; should not happen\");\n        }\n        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);\n        return Object.assign({}, overrides, await resolveProperties({\n            to: contract.getAddress(),\n            data: contract.interface.encodeFunctionData(fragment, resolvedArgs)\n        }));\n    };\n    const staticCall = async function (...args) {\n        const result = await staticCallResult(...args);\n        if (result.length === 1) {\n            return result[0];\n        }\n        return result;\n    };\n    const send = async function (...args) {\n        const runner = contract.runner;\n        assert(canSend(runner), \"contract runner does not support sending transactions\", \"UNSUPPORTED_OPERATION\", { operation: \"sendTransaction\" });\n        const tx = await runner.sendTransaction(await populateTransaction(...args));\n        const provider = getProvider(contract.runner);\n        // @TODO: the provider can be null; make a custom dummy provider that will throw a\n        // meaningful error\n        return new ContractTransactionResponse(contract.interface, provider, tx);\n    };\n    const estimateGas = async function (...args) {\n        const runner = getRunner(contract.runner, \"estimateGas\");\n        assert(canEstimate(runner), \"contract runner does not support gas estimation\", \"UNSUPPORTED_OPERATION\", { operation: \"estimateGas\" });\n        return await runner.estimateGas(await populateTransaction(...args));\n    };\n    const staticCallResult = async function (...args) {\n        const runner = getRunner(contract.runner, \"call\");\n        assert(canCall(runner), \"contract runner does not support calling\", \"UNSUPPORTED_OPERATION\", { operation: \"call\" });\n        const tx = await populateTransaction(...args);\n        let result = \"0x\";\n        try {\n            result = await runner.call(tx);\n        }\n        catch (error) {\n            if (isCallException(error) && error.data) {\n                throw contract.interface.makeError(error.data, tx);\n            }\n            throw error;\n        }\n        const fragment = getFragment(...args);\n        return contract.interface.decodeFunctionResult(fragment, result);\n    };\n    const method = async (...args) => {\n        const fragment = getFragment(...args);\n        if (fragment.constant) {\n            return await staticCall(...args);\n        }\n        return await send(...args);\n    };\n    defineProperties(method, {\n        name: contract.interface.getFunctionName(key),\n        _contract: contract, _key: key,\n        getFragment,\n        estimateGas,\n        populateTransaction,\n        send, staticCall, staticCallResult,\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getFunction(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\nfunction buildWrappedEvent(contract, key) {\n    const getFragment = function (...args) {\n        const fragment = contract.interface.getEvent(key, args);\n        assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"fragment\",\n            info: { key, args }\n        });\n        return fragment;\n    };\n    const method = function (...args) {\n        return new PreparedTopicFilter(contract, getFragment(...args), args);\n    };\n    defineProperties(method, {\n        name: contract.interface.getEventName(key),\n        _contract: contract, _key: key,\n        getFragment\n    });\n    // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)\n    Object.defineProperty(method, \"fragment\", {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n            const fragment = contract.interface.getEvent(key);\n            assert(fragment, \"no matching fragment\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"fragment\",\n                info: { key }\n            });\n            return fragment;\n        }\n    });\n    return method;\n}\n// The combination of TypeScrype, Private Fields and Proxies makes\n// the world go boom; so we hide variables with some trickery keeping\n// a symbol attached to each BaseContract which its sub-class (even\n// via a Proxy) can reach and use to look up its internal values.\nconst internal = Symbol.for(\"_ethersInternal_contract\");\nconst internalValues = new WeakMap();\nfunction setInternal(contract, values) {\n    internalValues.set(contract[internal], values);\n}\nfunction getInternal(contract) {\n    return internalValues.get(contract[internal]);\n}\nfunction isDeferred(value) {\n    return (value && typeof (value) === \"object\" && (\"getTopicFilter\" in value) &&\n        (typeof (value.getTopicFilter) === \"function\") && value.fragment);\n}\nasync function getSubInfo(contract, event) {\n    let topics;\n    let fragment = null;\n    // Convert named events to topicHash and get the fragment for\n    // events which need deconstructing.\n    if (Array.isArray(event)) {\n        const topicHashify = function (name) {\n            if (isHexString(name, 32)) {\n                return name;\n            }\n            const fragment = contract.interface.getEvent(name);\n            assertArgument(fragment, \"unknown fragment\", \"name\", name);\n            return fragment.topicHash;\n        };\n        // Array of Topics and Names; e.g. `[ \"0x1234...89ab\", \"Transfer(address)\" ]`\n        topics = event.map((e) => {\n            if (e == null) {\n                return null;\n            }\n            if (Array.isArray(e)) {\n                return e.map(topicHashify);\n            }\n            return topicHashify(e);\n        });\n    }\n    else if (event === \"*\") {\n        topics = [null];\n    }\n    else if (typeof (event) === \"string\") {\n        if (isHexString(event, 32)) {\n            // Topic Hash\n            topics = [event];\n        }\n        else {\n            // Name or Signature; e.g. `\"Transfer\", `\"Transfer(address)\"`\n            fragment = contract.interface.getEvent(event);\n            assertArgument(fragment, \"unknown fragment\", \"event\", event);\n            topics = [fragment.topicHash];\n        }\n    }\n    else if (isDeferred(event)) {\n        // Deferred Topic Filter; e.g. `contract.filter.Transfer(from)`\n        topics = await event.getTopicFilter();\n    }\n    else if (\"fragment\" in event) {\n        // ContractEvent; e.g. `contract.filter.Transfer`\n        fragment = event.fragment;\n        topics = [fragment.topicHash];\n    }\n    else {\n        assertArgument(false, \"unknown event name\", \"event\", event);\n    }\n    // Normalize topics and sort TopicSets\n    topics = topics.map((t) => {\n        if (t == null) {\n            return null;\n        }\n        if (Array.isArray(t)) {\n            const items = Array.from(new Set(t.map((t) => t.toLowerCase())).values());\n            if (items.length === 1) {\n                return items[0];\n            }\n            items.sort();\n            return items;\n        }\n        return t.toLowerCase();\n    });\n    const tag = topics.map((t) => {\n        if (t == null) {\n            return \"null\";\n        }\n        if (Array.isArray(t)) {\n            return t.join(\"|\");\n        }\n        return t;\n    }).join(\"&\");\n    return { fragment, tag, topics };\n}\nasync function hasSub(contract, event) {\n    const { subs } = getInternal(contract);\n    return subs.get((await getSubInfo(contract, event)).tag) || null;\n}\nasync function getSub(contract, operation, event) {\n    // Make sure our runner can actually subscribe to events\n    const provider = getProvider(contract.runner);\n    assert(provider, \"contract runner does not support subscribing\", \"UNSUPPORTED_OPERATION\", { operation });\n    const { fragment, tag, topics } = await getSubInfo(contract, event);\n    const { addr, subs } = getInternal(contract);\n    let sub = subs.get(tag);\n    if (!sub) {\n        const address = (addr ? addr : contract);\n        const filter = { address, topics };\n        const listener = (log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = contract.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            // If fragment is null, we do not deconstruct the args to emit\n            if (foundFragment) {\n                const _foundFragment = foundFragment;\n                const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];\n                emit(contract, event, args, (listener) => {\n                    return new ContractEventPayload(contract, listener, event, _foundFragment, log);\n                });\n            }\n            else {\n                emit(contract, event, [], (listener) => {\n                    return new ContractUnknownEventPayload(contract, listener, event, log);\n                });\n            }\n        };\n        let starting = [];\n        const start = () => {\n            if (starting.length) {\n                return;\n            }\n            starting.push(provider.on(filter, listener));\n        };\n        const stop = async () => {\n            if (starting.length == 0) {\n                return;\n            }\n            let started = starting;\n            starting = [];\n            await Promise.all(started);\n            provider.off(filter, listener);\n        };\n        sub = { tag, listeners: [], start, stop };\n        subs.set(tag, sub);\n    }\n    return sub;\n}\n// We use this to ensure one emit resolves before firing the next to\n// ensure correct ordering (note this cannot throw and just adds the\n// notice to the event queu using setTimeout).\nlet lastEmit = Promise.resolve();\nasync function _emit(contract, event, args, payloadFunc) {\n    await lastEmit;\n    const sub = await hasSub(contract, event);\n    if (!sub) {\n        return false;\n    }\n    const count = sub.listeners.length;\n    sub.listeners = sub.listeners.filter(({ listener, once }) => {\n        const passArgs = Array.from(args);\n        if (payloadFunc) {\n            passArgs.push(payloadFunc(once ? null : listener));\n        }\n        try {\n            listener.call(contract, ...passArgs);\n        }\n        catch (error) { }\n        return !once;\n    });\n    if (sub.listeners.length === 0) {\n        sub.stop();\n        getInternal(contract).subs.delete(sub.tag);\n    }\n    return (count > 0);\n}\nasync function emit(contract, event, args, payloadFunc) {\n    try {\n        await lastEmit;\n    }\n    catch (error) { }\n    const resultPromise = _emit(contract, event, args, payloadFunc);\n    lastEmit = resultPromise;\n    return await resultPromise;\n}\nconst passProperties = [\"then\"];\nexport class BaseContract {\n    /**\n     *  The target to connect to.\n     *\n     *  This can be an address, ENS name or any [[Addressable]], such as\n     *  another contract. To get the resovled address, use the ``getAddress``\n     *  method.\n     */\n    target;\n    /**\n     *  The contract Interface.\n     */\n    interface;\n    /**\n     *  The connected runner. This is generally a [[Provider]] or a\n     *  [[Signer]], which dictates what operations are supported.\n     *\n     *  For example, a **Contract** connected to a [[Provider]] may\n     *  only execute read-only operations.\n     */\n    runner;\n    /**\n     *  All the Events available on this contract.\n     */\n    filters;\n    /**\n     *  @_ignore:\n     */\n    [internal];\n    /**\n     *  The fallback or receive function if any.\n     */\n    fallback;\n    /**\n     *  Creates a new contract connected to %%target%% with the %%abi%% and\n     *  optionally connected to a %%runner%% to perform operations on behalf\n     *  of.\n     */\n    constructor(target, abi, runner, _deployTx) {\n        assertArgument(typeof (target) === \"string\" || isAddressable(target), \"invalid value for Contract target\", \"target\", target);\n        if (runner == null) {\n            runner = null;\n        }\n        const iface = Interface.from(abi);\n        defineProperties(this, { target, runner, interface: iface });\n        Object.defineProperty(this, internal, { value: {} });\n        let addrPromise;\n        let addr = null;\n        let deployTx = null;\n        if (_deployTx) {\n            const provider = getProvider(runner);\n            // @TODO: the provider can be null; make a custom dummy provider that will throw a\n            // meaningful error\n            deployTx = new ContractTransactionResponse(this.interface, provider, _deployTx);\n        }\n        let subs = new Map();\n        // Resolve the target as the address\n        if (typeof (target) === \"string\") {\n            if (isHexString(target)) {\n                addr = target;\n                addrPromise = Promise.resolve(target);\n            }\n            else {\n                const resolver = getRunner(runner, \"resolveName\");\n                if (!canResolve(resolver)) {\n                    throw makeError(\"contract runner does not support name resolution\", \"UNSUPPORTED_OPERATION\", {\n                        operation: \"resolveName\"\n                    });\n                }\n                addrPromise = resolver.resolveName(target).then((addr) => {\n                    if (addr == null) {\n                        throw makeError(\"an ENS name used for a contract target must be correctly configured\", \"UNCONFIGURED_NAME\", {\n                            value: target\n                        });\n                    }\n                    getInternal(this).addr = addr;\n                    return addr;\n                });\n            }\n        }\n        else {\n            addrPromise = target.getAddress().then((addr) => {\n                if (addr == null) {\n                    throw new Error(\"TODO\");\n                }\n                getInternal(this).addr = addr;\n                return addr;\n            });\n        }\n        // Set our private values\n        setInternal(this, { addrPromise, addr, deployTx, subs });\n        // Add the event filters\n        const filters = new Proxy({}, {\n            get: (target, prop, receiver) => {\n                // Pass important checks (like `then` for Promise) through\n                if (typeof (prop) === \"symbol\" || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                try {\n                    return this.getEvent(prop);\n                }\n                catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                // Pass important checks (like `then` for Promise) through\n                if (passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return Reflect.has(target, prop) || this.interface.hasEvent(String(prop));\n            }\n        });\n        defineProperties(this, { filters });\n        defineProperties(this, {\n            fallback: ((iface.receive || iface.fallback) ? (buildWrappedFallback(this)) : null)\n        });\n        // Return a Proxy that will respond to functions\n        return new Proxy(this, {\n            get: (target, prop, receiver) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Undefined properties should return undefined\n                try {\n                    return target.getFunction(prop);\n                }\n                catch (error) {\n                    if (!isError(error, \"INVALID_ARGUMENT\") || error.argument !== \"key\") {\n                        throw error;\n                    }\n                }\n                return undefined;\n            },\n            has: (target, prop) => {\n                if (typeof (prop) === \"symbol\" || prop in target || passProperties.indexOf(prop) >= 0) {\n                    return Reflect.has(target, prop);\n                }\n                return target.interface.hasFunction(prop);\n            }\n        });\n    }\n    /**\n     *  Return a new Contract instance with the same target and ABI, but\n     *  a different %%runner%%.\n     */\n    connect(runner) {\n        return new BaseContract(this.target, this.interface, runner);\n    }\n    /**\n     *  Return a new Contract instance with the same ABI and runner, but\n     *  a different %%target%%.\n     */\n    attach(target) {\n        return new BaseContract(target, this.interface, this.runner);\n    }\n    /**\n     *  Return the resolved address of this Contract.\n     */\n    async getAddress() { return await getInternal(this).addrPromise; }\n    /**\n     *  Return the deployed bytecode or null if no bytecode is found.\n     */\n    async getDeployedCode() {\n        const provider = getProvider(this.runner);\n        assert(provider, \"runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"getDeployedCode\" });\n        const code = await provider.getCode(await this.getAddress());\n        if (code === \"0x\") {\n            return null;\n        }\n        return code;\n    }\n    /**\n     *  Resolve to this Contract once the bytecode has been deployed, or\n     *  resolve immediately if already deployed.\n     */\n    async waitForDeployment() {\n        // We have the deployement transaction; just use that (throws if deployement fails)\n        const deployTx = this.deploymentTransaction();\n        if (deployTx) {\n            await deployTx.wait();\n            return this;\n        }\n        // Check for code\n        const code = await this.getDeployedCode();\n        if (code != null) {\n            return this;\n        }\n        // Make sure we can subscribe to a provider event\n        const provider = getProvider(this.runner);\n        assert(provider != null, \"contract runner does not support .provider\", \"UNSUPPORTED_OPERATION\", { operation: \"waitForDeployment\" });\n        return new Promise((resolve, reject) => {\n            const checkCode = async () => {\n                try {\n                    const code = await this.getDeployedCode();\n                    if (code != null) {\n                        return resolve(this);\n                    }\n                    provider.once(\"block\", checkCode);\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            checkCode();\n        });\n    }\n    /**\n     *  Return the transaction used to deploy this contract.\n     *\n     *  This is only available if this instance was returned from a\n     *  [[ContractFactory]].\n     */\n    deploymentTransaction() {\n        return getInternal(this).deployTx;\n    }\n    /**\n     *  Return the function for a given name. This is useful when a contract\n     *  method name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getFunction(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        const func = buildWrappedMethod(this, key);\n        return func;\n    }\n    /**\n     *  Return the event for a given name. This is useful when a contract\n     *  event name conflicts with a JavaScript name such as ``prototype`` or\n     *  when using a Contract programatically.\n     */\n    getEvent(key) {\n        if (typeof (key) !== \"string\") {\n            key = key.format();\n        }\n        return buildWrappedEvent(this, key);\n    }\n    /**\n     *  @_ignore:\n     */\n    async queryTransaction(hash) {\n        throw new Error(\"@TODO\");\n    }\n    /*\n    // @TODO: this is a non-backwards compatible change, but will be added\n    //        in v7 and in a potential SmartContract class in an upcoming\n    //        v6 release\n    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\",\n            \"UNSUPPORTED_OPERATION\", { operation: \"queryTransaction\" });\n\n        const receipt = await provider.getTransactionReceipt(hash);\n        if (receipt == null) { return null; }\n\n        return new ContractTransactionReceipt(this.interface, provider, receipt);\n    }\n    */\n    /**\n     *  Provide historic access to event data for %%event%% in the range\n     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``\"latest\"``)\n     *  inclusive.\n     */\n    async queryFilter(event, fromBlock, toBlock) {\n        if (fromBlock == null) {\n            fromBlock = 0;\n        }\n        if (toBlock == null) {\n            toBlock = \"latest\";\n        }\n        const { addr, addrPromise } = getInternal(this);\n        const address = (addr ? addr : (await addrPromise));\n        const { fragment, topics } = await getSubInfo(this, event);\n        const filter = { address, topics, fromBlock, toBlock };\n        const provider = getProvider(this.runner);\n        assert(provider, \"contract runner does not have a provider\", \"UNSUPPORTED_OPERATION\", { operation: \"queryFilter\" });\n        return (await provider.getLogs(filter)).map((log) => {\n            let foundFragment = fragment;\n            if (foundFragment == null) {\n                try {\n                    foundFragment = this.interface.getEvent(log.topics[0]);\n                }\n                catch (error) { }\n            }\n            if (foundFragment) {\n                try {\n                    return new EventLog(log, this.interface, foundFragment);\n                }\n                catch (error) {\n                    return new UndecodedEventLog(log, error);\n                }\n            }\n            return new Log(log, provider);\n        });\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%.\n     */\n    async on(event, listener) {\n        const sub = await getSub(this, \"on\", event);\n        sub.listeners.push({ listener, once: false });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Add an event %%listener%% for the %%event%%, but remove the listener\n     *  after it is fired once.\n     */\n    async once(event, listener) {\n        const sub = await getSub(this, \"once\", event);\n        sub.listeners.push({ listener, once: true });\n        sub.start();\n        return this;\n    }\n    /**\n     *  Emit an %%event%% calling all listeners with %%args%%.\n     *\n     *  Resolves to ``true`` if any listeners were called.\n     */\n    async emit(event, ...args) {\n        return await emit(this, event, args, null);\n    }\n    /**\n     *  Resolves to the number of listeners of %%event%% or the total number\n     *  of listeners if unspecified.\n     */\n    async listenerCount(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return 0;\n            }\n            return sub.listeners.length;\n        }\n        const { subs } = getInternal(this);\n        let total = 0;\n        for (const { listeners } of subs.values()) {\n            total += listeners.length;\n        }\n        return total;\n    }\n    /**\n     *  Resolves to the listeners subscribed to %%event%% or all listeners\n     *  if unspecified.\n     */\n    async listeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return [];\n            }\n            return sub.listeners.map(({ listener }) => listener);\n        }\n        const { subs } = getInternal(this);\n        let result = [];\n        for (const { listeners } of subs.values()) {\n            result = result.concat(listeners.map(({ listener }) => listener));\n        }\n        return result;\n    }\n    /**\n     *  Remove the %%listener%% from the listeners for %%event%% or remove\n     *  all listeners if unspecified.\n     */\n    async off(event, listener) {\n        const sub = await hasSub(this, event);\n        if (!sub) {\n            return this;\n        }\n        if (listener) {\n            const index = sub.listeners.map(({ listener }) => listener).indexOf(listener);\n            if (index >= 0) {\n                sub.listeners.splice(index, 1);\n            }\n        }\n        if (listener == null || sub.listeners.length === 0) {\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        return this;\n    }\n    /**\n     *  Remove all the listeners for %%event%% or remove all listeners if\n     *  unspecified.\n     */\n    async removeAllListeners(event) {\n        if (event) {\n            const sub = await hasSub(this, event);\n            if (!sub) {\n                return this;\n            }\n            sub.stop();\n            getInternal(this).subs.delete(sub.tag);\n        }\n        else {\n            const { subs } = getInternal(this);\n            for (const { tag, stop } of subs.values()) {\n                stop();\n                subs.delete(tag);\n            }\n        }\n        return this;\n    }\n    /**\n     *  Alias for [on].\n     */\n    async addListener(event, listener) {\n        return await this.on(event, listener);\n    }\n    /**\n     *  Alias for [off].\n     */\n    async removeListener(event, listener) {\n        return await this.off(event, listener);\n    }\n    /**\n     *  Create a new Class for the %%abi%%.\n     */\n    static buildClass(abi) {\n        class CustomContract extends BaseContract {\n            constructor(address, runner = null) {\n                super(address, abi, runner);\n            }\n        }\n        return CustomContract;\n    }\n    ;\n    /**\n     *  Create a new BaseContract with a specified Interface.\n     */\n    static from(target, abi, runner) {\n        if (runner == null) {\n            runner = null;\n        }\n        const contract = new this(target, abi, runner);\n        return contract;\n    }\n}\nfunction _ContractBase() {\n    return BaseContract;\n}\n/**\n *  A [[BaseContract]] with no type guards on its methods or events.\n */\nexport class Contract extends _ContractBase() {\n}\n//# sourceMappingURL=contract.js.map"],"names":["checkType","value","type","name","types","split","map","t","trim","i","length","error","Error","code","argument","async","resolveProperties","keys","Object","Promise","all","k","resolve","reduce","accum","v","index","defineProperties","target","values","key","defineProperty","enumerable","writable","stringify","Array","isArray","join","Uint8Array","HEX","result","toJSON","toString","BigInt","JSON","sort","isError","isCallException","makeError","message","info","shortMessage","details","push","TypeError","RangeError","assign","assert","check","assertArgument","assertArgumentCount","count","expectedCount","_normalizeForms","form","normalize","String","fromCharCode","assertPrivate","givenGuard","guard","className","method","operation","_getBytes","copy","match","offset","parseInt","substring","getBytes","getBytesCopy","isHexString","HexCharacters","hexlify","data","bytes","concat","datas","d","dataSlice","start","end","buffer","slice","zeroPad","left","fill","set","zeroPadValue","zeroPadBytes","BN_0","BN_1","maxValue","fromTwos","_value","_width","getUint","width","getNumber","fault","toTwos","getBigInt","limit","mask","_bits","bits","Number","isInteger","e","Nibbles","toBigInt","toBeHex","toBeArray","hex","EventPayload","filter","emitter","listener","constructor","this","removeListener","off","ignoreFunc","reason","output","badCodepoint","o","Utf8ErrorFuncs","freeze","ignore","replace","toUtf8Bytes","str","indexOf","assertNormalize","c","charCodeAt","c2","pair","toUtf8String","onError","codePoints","_bytes","extraLength","overlongMask","res","j","nextChar","getUtf8CodePoints","codePoint","BN_N1","BN_5","_guard","Zeros","getTens","decimals","checkValue","val","format","safeOp","signed","getFormat","defaultValue","FixedNumber","tens","negative","checkFormat","other","add","addUnsafe","sub","subUnsafe","mul","mulUnsafe","mulSignal","div","divUnsafe","divSignal","cmp","a","b","delta","eq","lt","lte","gt","gte","floor","ceiling","round","bump","isZero","isNegative","toUnsafeFloat","parseFloat","toFormat","fromString","fromValue","_decimals","_format","whole","decimal","fromBytes","names","parseUnits","unit","WordSize","Padding","passProperties","resultNames","WeakMap","getNames","get","setNames","throwError","wrapped","toObject","items","deep","item","Result","getValue","args","wrap","super","forEach","nameCounts","Map","proxy","Proxy","prop","receiver","Reflect","Function","apply","toArray","_names","callback","thisArg","call","fromItems","Coder","localName","dynamic","_throwError","Writer","dataLength","writeData","appendWriter","writer","writeBytes","paddingOffset","writeValue","writeUpdatableValue","Reader","allowLoose","bytesRead","parent","maxInflation","consumed","incrementBytesRead","peekBytes","loose","alignedLength","Math","ceil","subReader","reader","readBytes","readValue","readIndex","number","n","isSafeInteger","lengths","includes","exists","instance","checkFinished","destroyed","finished","U32_MASK64","_32n","fromBig","le","h","l","lst","Ah","Uint32Array","Al","toBytes","TextEncoder","encode","utf8ToBytes","Hash","clone","_cloneInto","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","_1n","_2n","_7n","_256n","_0x71n","R","x","y","SHA3_IOTA_H","SHA3_IOTA_L","rotlH","s","rotlBH","rotlSH","rotlL","rotlBL","rotlSL","Keccak","blockLen","suffix","outputLen","enableXOF","rounds","pos","posOut","arr","state","state32","byteOffset","byteLength","keccak","B","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","keccakP","update","len","take","min","finish","writeInto","out","bufferOut","subarray","xofInto","xof","digestInto","destroy","digest","to","keccak_256","hashCons","hashC","msg","tmp","create","wrapConstructor","gen","locked","_keccak256","__keccak256","keccak256","_data","_","lock","register","func","ZeroAddress","BN_36","getChecksumAddress","address","chars","toLowerCase","expanded","hashed","toUpperCase","ibanLookup","Base36","getAddress","startsWith","block","checksum","ibanChecksum","fromBase36","isAddressable","checkAddress","promise","resolveAddress","resolver","resolveName","_gaurd","Typed","size","_typedSymbol","Symbol","for","options","gaurd","minValue","isBigInt","isData","isString","tupleName","arrayLength","from","uint8","uint16","uint24","uint32","uint40","uint48","uint56","uint64","uint72","uint80","uint88","uint96","uint104","uint112","uint120","uint128","uint136","uint144","uint152","uint160","uint168","uint176","uint184","uint192","uint200","uint208","uint216","uint224","uint232","uint240","uint248","uint256","uint","int8","int16","int24","int32","int40","int48","int56","int64","int72","int80","int88","int96","int104","int112","int120","int128","int136","int144","int152","int160","int168","int176","int184","int192","int200","int208","int216","int224","int232","int240","int248","int256","int","bytes1","bytes2","bytes3","bytes4","bytes5","bytes6","bytes7","bytes8","bytes9","bytes10","bytes11","bytes12","bytes13","bytes14","bytes15","bytes16","bytes17","bytes18","bytes19","bytes20","bytes21","bytes22","bytes23","bytes24","bytes25","bytes26","bytes27","bytes28","bytes29","bytes30","bytes31","bytes32","bool","string","array","tuple","overrides","isTyped","dereference","AddressCoder","decode","AnonymousCoder","coder","pack","coders","arrayValues","unique","staticWriter","dynamicWriter","updateFuncs","dynamicOffset","updateFunc","baseOffset","unpack","baseReader","offsetReader","baseType","undefined","ArrayCoder","defaultChild","BooleanCoder","DynamicBytesCoder","BytesCoder","FixedBytesCoder","Empty","NullCoder","BN_MAX_UINT256","NumberCoder","maxUintValue","bounds","StringCoder","TupleCoder","uniqueNames","id","accessSetify","addr","storageKeys","storageKey","regexBytes","RegExp","regexNumber","regexArray","_pack","setify","Set","KwVisibDeploy","_kwVisib","KwVisib","_kwTypes","KwTypes","_kwModifiers","KwModifiers","Keywords","SimpleTokens","regexWhitespacePrefix","regexNumberPrefix","regexIdPrefix","regexId","regexType","TokenString","tokens","reset","subTokenString","linkBack","linkNext","popKeyword","allowed","top","peek","has","text","pop","popType","popParen","popParams","link","peekKeyword","peekType","token","lex","brackets","commas","cur","depth","allowSingle","included","consumeName","keyword","consumeKeywords","keywords","consumeMutability","modifiers","consumeParams","allowIndexed","ParamType","consumeGas","consumeEoi","regexArrayType","verifyBasicType","internal","ParamTypeInternal","ErrorFragmentInternal","EventFragmentInternal","ConstructorFragmentInternal","FallbackFragmentInternal","FunctionFragmentInternal","StructFragmentInternal","indexed","components","arrayChildren","parse","isTuple","comp","isIndexable","walk","process","_this","walkAsync","promises","setValue","childType","param","then","obj","isParamType","comps","bracket","arrayMatch","Fragment","inputs","ConstructorFragment","ErrorFragment","EventFragment","FallbackFragment","FunctionFragment","StructFragment","isConstructor","isFragment","isEvent","isFunction","isStruct","NamedFragment","joinParams","params","p","selector","input","anonymous","topicHash","getTopicHash","payable","gas","stateMutability","errorObj","mutability","outputs","constant","getSelector","PanicReasons","paramTypeBytes","paramTypeNumber","defaultCoder","defaultMaxInflation","AbiCoder","getCoder","getDefaultValue","_setDefaultMaxInflation","defaultAbiCoder","getBuiltinCallException","action","tx","abiCoder","revert","signature","transaction","invocation","LogDescription","fragment","topic","TransactionDescription","ErrorDescription","Indexed","hash","_isIndexed","isIndexed","BuiltinErrors","Interface","fragments","deploy","fallback","receive","errors","events","functions","abi","frags","console","log","getAbiCoder","bucket","minimal","f","formatJson","getFunction","forceUnique","matching","lastValue","valueLength","allowOptions","splice","lastArg","m","getFunctionName","hasFunction","forEachFunction","localeCompare","getEvent","eventTopic","getEventName","hasEvent","forEachEvent","getError","forEachError","_decodeParams","_encodeParams","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","encodeFunctionData","decodeFunctionResult","ef","parsed","parseTransaction","encodeFunctionResult","encodeFilterTopics","topics","encodeTopic","encodeEventLog","dataTypes","dataValues","decodeEventLog","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","parseCallResult","parseLog","parseError","hexData","toJson","copyRequest","req","bigIntKeys","numberKeys","accessList","accessListify","blockTag","enableCcipRead","customData","blobVersionedHashes","kzg","blobs","Log","provider","transactionHash","blockHash","blockNumber","removed","transactionIndex","_type","getBlock","getTransaction","getTransactionReceipt","receipt","removedEvent","orphan","TransactionReceipt","contractAddress","logsBloom","gasUsed","blobGasUsed","cumulativeGasUsed","gasPrice","blobGasPrice","status","root","logs","effectiveGasPrice","iterator","next","done","fee","getResult","getTransactionResult","confirmations","getBlockNumber","createRemovedTransactionFilter","reorderedEvent","isMined","createReorderedTransactionFilter","TransactionResponse","nonce","gasLimit","maxPriorityFeePerGas","maxFeePerGas","maxFeePerBlobGas","chainId","startBlock","wait","_confirms","_timeout","confirms","timeout","nextScan","stopScanning","checkReplacement","getTransactionCount","mined","cancelled","replacement","replaceableTransaction","checkReceipt","waiter","reject","cancellers","cancel","timer","setTimeout","clearTimeout","txListener","on","replaceListener","once","isLegacy","isBerlin","isLondon","isCancun","EventLog","interface","iface","eventName","eventSignature","UndecodedEventLog","ContractTransactionReceipt","ContractTransactionResponse","ContractUnknownEventPayload","contract","ContractEventPayload","_log","canCall","canEstimate","canResolve","canSend","getResolver","PreparedTopicFilter","runner","getRunner","resolvedArgs","getTopicFilter","feature","getProvider","copyOverrides","arg","_overrides","buildWrappedFallback","populateTransaction","noValue","noData","send","sendTransaction","_contract","estimateGas","staticCall","buildWrappedMethod","getFragment","_runner","resolveArgs","staticCallResult","_key","configurable","internalValues","getInternal","getSubInfo","event","topicHashify","tag","hasSub","subs","getSub","foundFragment","_foundFragment","emit","starting","listeners","stop","started","lastEmit","payloadFunc","resultPromise","passArgs","delete","_emit","BaseContract","filters","_deployTx","addrPromise","deployTx","connect","attach","getDeployedCode","getCode","waitForDeployment","deploymentTransaction","checkCode","buildWrappedEvent","queryTransaction","queryFilter","fromBlock","toBlock","getLogs","listenerCount","total","removeAllListeners","addListener","buildClass","Contract","_ContractBase","tight"],"mappings":"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"}